	                
	                ;**************************************************************
	                ;*
	                ;*             C P / M   version   2 . 2
	                ;*
	                ;*   Reconstructed from memory image on February 27, 1981
	                ;*
	                ;*                by Clark A. Calkins
	                ;*
	                ;**************************************************************
	                ;
	                ;   Set memory limit here. This is the amount of contigeous
	                ; ram starting from 0000. CP/M will reside at the end of this space.
	                ;
	                MEM	EQU	62	;for a 62k system (TS802 TEST - WORKS OK).
	                ;
	                IOBYTE	EQU	3	;i/o definition byte.
	                TDRIVE	EQU	4	;current drive name and user number.
	                ENTRY	EQU	5	;entry point for the cp/m bdos.
	                TFCB	EQU	5CH	;default file control block.
	                TBUFF	EQU	80H	;i/o buffer and command line storage.
	                TBASE	EQU	100H	;transiant program storage area.
	                ;
	                ;   Set control character equates.
	                ;
	                CNTRLC	EQU	3	;control-c
	                CNTRLE	EQU	05H	;control-e
	                BS	EQU	08H	;backspace
	                TAB	EQU	09H	;tab
	                LF	EQU	0AH	;line feed
	                FF	EQU	0CH	;form feed
	                CR	EQU	0DH	;carriage return
	                CNTRLP	EQU	10H	;control-p
	                CNTRLR	EQU	12H	;control-r
	                CNTRLS	EQU	13H	;control-s
	                CNTRLU	EQU	15H	;control-u
	                CNTRLX	EQU	18H	;control-x
	                CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
	                DEL	EQU	7FH	;rubout
	                ;
	                ;   Set origin for CP/M
	                ;
	                	ORG	(MEM-7)*1024
	                ;
DC00	C3 5C DF        CBASE	JMP	COMMAND	;execute command processor (ccp).
DC03	C3 58 DF        	JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
	                
	                ;
	                ;   Standard cp/m ccp input buffer. Format is (max length),
	                ; (actual length), (char #1), (char #2), (char #3), etc.
	                ;
DC06	7F              INBUFF	DB	127	;length of input buffer.
DC07	00              	DB	0	;current length of contents.
DC08	43 6F 70 79     	DB	'Copyright'
	. . .
DC10	74 

DC11	20 31 39 37     	DB	' 1979 (c) by Digital Research      '
	. . .
DC31	20 20 20 

DC34	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
DC48	00 00 00 

DC4B	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
DC5F	00 00 00 

DC62	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
DC76	00 00 00 

DC79	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
DC85	00 00 00 

DC88	08 DC           INPOINT	DW	INBUFF+2;input line pointer
DC8A	00 00           NAMEPNT	DW	0	;input line pointer used for error message. Points to
	                ;			;start of name in error.
	                ;
	                ;   Routine to print (A) on the console. All registers used.
	                ;
DC8C	5F              PRINT	MOV	E,A	;setup bdos call.
DC8D	0E 02           	MVI	C,2
DC8F	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Routine to print (A) on the console and to save (BC).
	                ;
DC92	C5              PRINTB	PUSH	B
DC93	CD 8C DC        	CALL	PRINT
DC96	C1              	POP	B
DC97	C9              	RET
	                ;
	                ;   Routine to send a carriage return, line feed combination
	                ; to the console.
	                ;
DC98	3E 0D           CRLF	MVI	A,CR
DC9A	CD 92 DC        	CALL	PRINTB
DC9D	3E 0A           	MVI	A,LF
DC9F	C3 92 DC        	JMP	PRINTB
	                ;
	                ;   Routine to send one space to the console and save (BC).
	                ;
DCA2	3E 20           SPACE	MVI	A,' '
DCA4	C3 92 DC        	JMP	PRINTB
	                ;
	                ;   Routine to print character string pointed to be (BC) on the
	                ; console. It must terminate with a null byte.
	                ;
DCA7	C5              PLINE	PUSH	B
DCA8	CD 98 DC        	CALL	CRLF
DCAB	E1              	POP	H
DCAC	7E              PLINE2	MOV	A,M
DCAD	B7              	ORA	A
DCAE	C8              	RZ
DCAF	23              	INX	H
DCB0	E5              	PUSH	H
DCB1	CD 8C DC        	CALL	PRINT
DCB4	E1              	POP	H
DCB5	C3 AC DC        	JMP	PLINE2
	                ;
	                ;   Routine to reset the disk system.
	                ;
DCB8	0E 0D           RESDSK	MVI	C,13
DCBA	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Routine to select disk (A).
	                ;
DCBD	5F              DSKSEL	MOV	E,A
DCBE	0E 0E           	MVI	C,14
DCC0	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Routine to call bdos and save the return code. The zero
	                ; flag is set on a return of 0ffh.
	                ;
DCC3	CD 05 00        ENTRY1	CALL	ENTRY
DCC6	32 EE E3        	STA	RTNCODE	;save return code.
DCC9	3C              	INR	A	;set zero if 0ffh returned.
DCCA	C9              	RET
	                ;
	                ;   Routine to open a file. (DE) must point to the FCB.
	                ;
DCCB	0E 0F           OPEN	MVI	C,15
DCCD	C3 C3 DC        	JMP	ENTRY1
	                ;
	                ;   Routine to open file at (FCB).
	                ;
DCD0	AF              OPENFCB	XRA	A	;clear the record number byte at fcb+32
DCD1	32 ED E3        	STA	FCB+32
DCD4	11 CD E3        	LXI	D,FCB
DCD7	C3 CB DC        	JMP	OPEN
	                ;
	                ;   Routine to close a file. (DE) points to FCB.
	                ;
DCDA	0E 10           CLOSE	MVI	C,16
DCDC	C3 C3 DC        	JMP	ENTRY1
	                ;
	                ;   Routine to search for the first file with ambigueous name
	                ; (DE).
	                ;
DCDF	0E 11           SRCHFST	MVI	C,17
DCE1	C3 C3 DC        	JMP	ENTRY1
	                ;
	                ;   Search for the next ambigeous file name.
	                ;
DCE4	0E 12           SRCHNXT	MVI	C,18
DCE6	C3 C3 DC        	JMP	ENTRY1
	                ;
	                ;   Search for file at (FCB).
	                ;
DCE9	11 CD E3        SRCHFCB	LXI	D,FCB
DCEC	C3 DF DC        	JMP	SRCHFST
	                ;
	                ;   Routine to delete a file pointed to by (DE).
	                ;
DCEF	0E 13           DELETE	MVI	C,19
DCF1	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Routine to call the bdos and set the zero flag if a zero
	                ; status is returned.
	                ;
DCF4	CD 05 00        ENTRY2	CALL	ENTRY
DCF7	B7              	ORA	A	;set zero flag if appropriate.
DCF8	C9              	RET
	                ;
	                ;   Routine to read the next record from a sequential file.
	                ; (DE) points to the FCB.
	                ;
DCF9	0E 14           RDREC	MVI	C,20
DCFB	C3 F4 DC        	JMP	ENTRY2
	                ;
	                ;   Routine to read file at (FCB).
	                ;
DCFE	11 CD E3        READFCB	LXI	D,FCB
DD01	C3 F9 DC        	JMP	RDREC
	                ;
	                ;   Routine to write the next record of a sequential file.
	                ; (DE) points to the FCB.
	                ;
DD04	0E 15           WRTREC	MVI	C,21
DD06	C3 F4 DC        	JMP	ENTRY2
	                ;
	                ;   Routine to create the file pointed to by (DE).
	                ;
DD09	0E 16           CREATE	MVI	C,22
DD0B	C3 C3 DC        	JMP	ENTRY1
	                ;
	                ;   Routine to rename the file pointed to by (DE). Note that
	                ; the new name starts at (DE+16).
	                ;
DD0E	0E 17           RENAM	MVI	C,23
DD10	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Get the current user code.
	                ;
DD13	1E FF           GETUSR	MVI	E,0FFH
	                ;
	                ;   Routne to get or set the current user code.
	                ; If (E) is FF then this is a GET, else it is a SET.
	                ;
DD15	0E 20           GETSETUC:MVI	C,32
DD17	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Routine to set the current drive byte at (TDRIVE).
	                ;
DD1A	CD 13 DD        SETCDRV	CALL	GETUSR	;get user number
DD1D	87              	ADD	A	;and shift into the upper 4 bits.
DD1E	87              	ADD	A
DD1F	87              	ADD	A
DD20	87              	ADD	A
DD21	21 EF E3        	LXI	H,CDRIVE;now add in the current drive number.
DD24	B6              	ORA	M
DD25	32 04 00        	STA	TDRIVE	;and save.
DD28	C9              	RET
	                ;
	                ;   Move currently active drive down to (TDRIVE).
	                ;
DD29	3A EF E3        MOVECD	LDA	CDRIVE
DD2C	32 04 00        	STA	TDRIVE
DD2F	C9              	RET
	                ;
	                ;   Routine to convert (A) into upper case ascii. Only letters
	                ; are affected.
	                ;
DD30	FE 61           UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
DD32	D8              	RC
DD33	FE 7B           	CPI	'{'
DD35	D0              	RNC
DD36	E6 5F           	ANI	5FH	;convert it if found.
DD38	C9              	RET
	                ;
	                ;   Routine to get a line of input. We must check to see if the
	                ; user is in (BATCH) mode. If so, then read the input from file
	                ; ($$$.SUB). At the end, reset to console input.
	                ;
DD39	3A AB E3        GETINP	LDA	BATCH	;if =0, then use console input.
DD3C	B7              	ORA	A
DD3D	CA 96 DD        	JZ	GETINP1
	                ;
	                ;   Use the submit file ($$$.sub) which is prepared by a
	                ; SUBMIT run. It must be on drive (A) and it will be deleted
	                ; if and error occures (like eof).
	                ;
DD40	3A EF E3        	LDA	CDRIVE	;select drive 0 if need be.
DD43	B7              	ORA	A
DD44	3E 00           	MVI	A,0	;always use drive A for submit.
DD46	C4 BD DC        	CNZ	DSKSEL	;select it if required.
DD49	11 AC E3        	LXI	D,BATCHFCB
DD4C	CD CB DC        	CALL	OPEN	;look for it.
DD4F	CA 96 DD        	JZ	GETINP1	;if not there, use normal input.
DD52	3A BB E3        	LDA	BATCHFCB+15;get last record number+1.
DD55	3D              	DCR	A
DD56	32 CC E3        	STA	BATCHFCB+32
DD59	11 AC E3        	LXI	D,BATCHFCB
DD5C	CD F9 DC        	CALL	RDREC	;read last record.
DD5F	C2 96 DD        	JNZ	GETINP1	;quit on end of file.
	                ;
	                ;   Move this record into input buffer.
	                ;
DD62	11 07 DC        	LXI	D,INBUFF+1
DD65	21 80 00        	LXI	H,TBUFF	;data was read into buffer here.
DD68	06 80           	MVI	B,128	;all 128 characters may be used.
DD6A	CD 42 E0        	CALL	HL2DE	;(HL) to (DE), (B) bytes.
DD6D	21 BA E3        	LXI	H,BATCHFCB+14
DD70	36 00           	MVI	M,0	;zero out the 's2' byte.
DD72	23              	INX	H	;and decrement the record count.
DD73	35              	DCR	M
DD74	11 AC E3        	LXI	D,BATCHFCB;close the batch file now.
DD77	CD DA DC        	CALL	CLOSE
DD7A	CA 96 DD        	JZ	GETINP1	;quit on an error.
DD7D	3A EF E3        	LDA	CDRIVE	;re-select previous drive if need be.
DD80	B7              	ORA	A
DD81	C4 BD DC        	CNZ	DSKSEL	;don't do needless selects.
	                ;
	                ;   Print line just read on console.
	                ;
DD84	21 08 DC        	LXI	H,INBUFF+2
DD87	CD AC DC        	CALL	PLINE2
DD8A	CD C2 DD        	CALL	CHKCON	;check console, quit on a key.
DD8D	CA A7 DD        	JZ	GETINP2	;jump if no key is pressed.
	                ;
	                ;   Terminate the submit job on any keyboard input. Delete this
	                ; file such that it is not re-started and jump to normal keyboard
	                ; input section.
	                ;
DD90	CD DD DD        	CALL	DELBATCH;delete the batch file.
DD93	C3 82 DF        	JMP	CMMND1	;and restart command input.
	                ;
	                ;   Get here for normal keyboard input. Delete the submit file
	                ; incase there was one.
	                ;
DD96	CD DD DD        GETINP1	CALL	DELBATCH;delete file ($$$.sub).
DD99	CD 1A DD        	CALL	SETCDRV	;reset active disk.
DD9C	0E 0A           	MVI	C,10	;get line from console device.
DD9E	11 06 DC        	LXI	D,INBUFF
DDA1	CD 05 00        	CALL	ENTRY
DDA4	CD 29 DD        	CALL	MOVECD	;reset current drive (again).
	                ;
	                ;   Convert input line to upper case.
	                ;
DDA7	21 07 DC        GETINP2	LXI	H,INBUFF+1
DDAA	46              	MOV	B,M	;(B)=character counter.
DDAB	23              GETINP3	INX	H
DDAC	78              	MOV	A,B	;end of the line?
DDAD	B7              	ORA	A
DDAE	CA BA DD        	JZ	GETINP4
DDB1	7E              	MOV	A,M	;convert to upper case.
DDB2	CD 30 DD        	CALL	UPPER
DDB5	77              	MOV	M,A
DDB6	05              	DCR	B	;adjust character count.
DDB7	C3 AB DD        	JMP	GETINP3
DDBA	77              GETINP4	MOV	M,A	;add trailing null.
DDBB	21 08 DC        	LXI	H,INBUFF+2
DDBE	22 88 DC        	SHLD	INPOINT	;reset input line pointer.
DDC1	C9              	RET
	                ;
	                ;   Routine to check the console for a key pressed. The zero
	                ; flag is set is none, else the character is returned in (A).
	                ;
DDC2	0E 0B           CHKCON	MVI	C,11	;check console.
DDC4	CD 05 00        	CALL	ENTRY
DDC7	B7              	ORA	A
DDC8	C8              	RZ		;return if nothing.
DDC9	0E 01           	MVI	C,1	;else get character.
DDCB	CD 05 00        	CALL	ENTRY
DDCE	B7              	ORA	A	;clear zero flag and return.
DDCF	C9              	RET
	                ;
	                ;   Routine to get the currently active drive number.
	                ;
DDD0	0E 19           GETDSK	MVI	C,25
DDD2	C3 05 00        	JMP	ENTRY
	                ;
	                ;   Set the stabdard dma address.
	                ;
DDD5	11 80 00        STDDMA	LXI	D,TBUFF
	                ;
	                ;   Routine to set the dma address to (DE).
	                ;
DDD8	0E 1A           DMASET	MVI	C,26
DDDA	C3 05 00        	JMP	ENTRY
	                ;
	                ;  Delete the batch file created by SUBMIT.
	                ;
DDDD	21 AB E3        DELBATCH:LXI	H,BATCH	;is batch active?
DDE0	7E              	MOV	A,M
DDE1	B7              	ORA	A
DDE2	C8              	RZ
DDE3	36 00           	MVI	M,0	;yes, de-activate it.
DDE5	AF              	XRA	A
DDE6	CD BD DC        	CALL	DSKSEL	;select drive 0 for sure.
DDE9	11 AC E3        	LXI	D,BATCHFCB;and delete this file.
DDEC	CD EF DC        	CALL	DELETE
DDEF	3A EF E3        	LDA	CDRIVE	;reset current drive.
DDF2	C3 BD DC        	JMP	DSKSEL
	                ;
	                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
	                ; the same or we halt....
	                ;
DDF5	11 28 DF        VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
DDF8	21 00 E4        	LXI	H,PATTRN2;ditto, but how could they be different?
DDFB	06 06           	MVI	B,6	;6 bytes each.
DDFD	1A              VERIFY1	LDAX	D
DDFE	BE              	CMP	M
DDFF	C2 CF DF        	JNZ	HALT	;jump to halt routine.
DE02	13              	INX	D
DE03	23              	INX	H
DE04	05              	DCR	B
DE05	C2 FD DD        	JNZ	VERIFY1
DE08	C9              	RET
	                ;
	                ;   Print back file name with a '?' to indicate a syntax error.
	                ;
DE09	CD 98 DC        SYNERR	CALL	CRLF	;end current line.
DE0C	2A 8A DC        	LHLD	NAMEPNT	;this points to name in error.
DE0F	7E              SYNERR1	MOV	A,M	;print it until a space or null is found.
DE10	FE 20           	CPI	' '
DE12	CA 22 DE        	JZ	SYNERR2
DE15	B7              	ORA	A
DE16	CA 22 DE        	JZ	SYNERR2
DE19	E5              	PUSH	H
DE1A	CD 8C DC        	CALL	PRINT
DE1D	E1              	POP	H
DE1E	23              	INX	H
DE1F	C3 0F DE        	JMP	SYNERR1
DE22	3E 3F           SYNERR2	MVI	A,'?'	;add trailing '?'.
DE24	CD 8C DC        	CALL	PRINT
DE27	CD 98 DC        	CALL	CRLF
DE2A	CD DD DD        	CALL	DELBATCH;delete any batch file.
DE2D	C3 82 DF        	JMP	CMMND1	;and restart from console input.
	                ;
	                ;   Check character at (DE) for legal command input. Note that the
	                ; zero flag is set if the character is a delimiter.
	                ;
DE30	1A              CHECK	LDAX	D
DE31	B7              	ORA	A
DE32	C8              	RZ
DE33	FE 20           	CPI	' '	;control characters are not legal here.
DE35	DA 09 DE        	JC	SYNERR
DE38	C8              	RZ		;check for valid delimiter.
DE39	FE 3D           	CPI	'='
DE3B	C8              	RZ
DE3C	FE 5F           	CPI	'_'
DE3E	C8              	RZ
DE3F	FE 2E           	CPI	'.'
DE41	C8              	RZ
DE42	FE 3A           	CPI	':'
DE44	C8              	RZ
DE45	FE 3B           	CPI	';'
DE47	C8              	RZ
DE48	FE 3C           	CPI	'<'
DE4A	C8              	RZ
DE4B	FE 3E           	CPI	'>'
DE4D	C8              	RZ
DE4E	C9              	RET
	                ;
	                ;   Get the next non-blank character from (DE).
	                ;
DE4F	1A              NONBLANK:LDAX	D
DE50	B7              	ORA	A	;string ends with a null.
DE51	C8              	RZ
DE52	FE 20           	CPI	' '
DE54	C0              	RNZ
DE55	13              	INX	D
DE56	C3 4F DE        	JMP	NONBLANK
	                ;
	                ;   Add (HL)=(HL)+(A)
	                ;
DE59	85              ADDHL	ADD	L
DE5A	6F              	MOV	L,A
DE5B	D0              	RNC	;take care of any carry.
DE5C	24              	INR	H
DE5D	C9              	RET
	                ;
	                ;   Convert the first name in (FCB).
	                ;
DE5E	3E 00           CONVFST	MVI	A,0
	                ;
	                ;   Format a file name (convert * to '?', etc.). On return,
	                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
	                ; the position within the fcb for the name (either 0 or 16).
	                ;
DE60	21 CD E3        CONVERT	LXI	H,FCB
DE63	CD 59 DE        	CALL	ADDHL
DE66	E5              	PUSH	H
DE67	E5              	PUSH	H
DE68	AF              	XRA	A
DE69	32 F0 E3        	STA	CHGDRV	;initialize drive change flag.
DE6C	2A 88 DC        	LHLD	INPOINT	;set (HL) as pointer into input line.
DE6F	EB              	XCHG
DE70	CD 4F DE        	CALL	NONBLANK;get next non-blank character.
DE73	EB              	XCHG
DE74	22 8A DC        	SHLD	NAMEPNT	;save pointer here for any error message.
DE77	EB              	XCHG
DE78	E1              	POP	H
DE79	1A              	LDAX	D	;get first character.
DE7A	B7              	ORA	A
DE7B	CA 89 DE        	JZ	CONVRT1
DE7E	DE 40           	SBI	'A'-1	;might be a drive name, convert to binary.
DE80	47              	MOV	B,A	;and save.
DE81	13              	INX	D	;check next character for a ':'.
DE82	1A              	LDAX	D
DE83	FE 3A           	CPI	':'
DE85	CA 90 DE        	JZ	CONVRT2
DE88	1B              	DCX	D	;nope, move pointer back to the start of the line.
DE89	3A EF E3        CONVRT1	LDA	CDRIVE
DE8C	77              	MOV	M,A
DE8D	C3 96 DE        	JMP	CONVRT3
DE90	78              CONVRT2	MOV	A,B
DE91	32 F0 E3        	STA	CHGDRV	;set change in drives flag.
DE94	70              	MOV	M,B
DE95	13              	INX	D
	                ;
	                ;   Convert the basic file name.
	                ;
DE96	06 08           CONVRT3	MVI	B,08H
DE98	CD 30 DE        CONVRT4	CALL	CHECK
DE9B	CA B9 DE        	JZ	CONVRT8
DE9E	23              	INX	H
DE9F	FE 2A           	CPI	'*'	;note that an '*' will fill the remaining
DEA1	C2 A9 DE        	JNZ	CONVRT5	;field with '?'.
DEA4	36 3F           	MVI	M,'?'
DEA6	C3 AB DE        	JMP	CONVRT6
DEA9	77              CONVRT5	MOV	M,A
DEAA	13              	INX	D
DEAB	05              CONVRT6	DCR	B
DEAC	C2 98 DE        	JNZ	CONVRT4
DEAF	CD 30 DE        CONVRT7	CALL	CHECK	;get next delimiter.
DEB2	CA C0 DE        	JZ	GETEXT
DEB5	13              	INX	D
DEB6	C3 AF DE        	JMP	CONVRT7
DEB9	23              CONVRT8	INX	H	;blank fill the file name.
DEBA	36 20           	MVI	M,' '
DEBC	05              	DCR	B
DEBD	C2 B9 DE        	JNZ	CONVRT8
	                ;
	                ;   Get the extension and convert it.
	                ;
DEC0	06 03           GETEXT	MVI	B,03H
DEC2	FE 2E           	CPI	'.'
DEC4	C2 E9 DE        	JNZ	GETEXT5
DEC7	13              	INX	D
DEC8	CD 30 DE        GETEXT1	CALL	CHECK
DECB	CA E9 DE        	JZ	GETEXT5
DECE	23              	INX	H
DECF	FE 2A           	CPI	'*'
DED1	C2 D9 DE        	JNZ	GETEXT2
DED4	36 3F           	MVI	M,'?'
DED6	C3 DB DE        	JMP	GETEXT3
DED9	77              GETEXT2	MOV	M,A
DEDA	13              	INX	D
DEDB	05              GETEXT3	DCR	B
DEDC	C2 C8 DE        	JNZ	GETEXT1
DEDF	CD 30 DE        GETEXT4	CALL	CHECK
DEE2	CA F0 DE        	JZ	GETEXT6
DEE5	13              	INX	D
DEE6	C3 DF DE        	JMP	GETEXT4
DEE9	23              GETEXT5	INX	H
DEEA	36 20           	MVI	M,' '
DEEC	05              	DCR	B
DEED	C2 E9 DE        	JNZ	GETEXT5
DEF0	06 03           GETEXT6	MVI	B,3
DEF2	23              GETEXT7	INX	H
DEF3	36 00           	MVI	M,0
DEF5	05              	DCR	B
DEF6	C2 F2 DE        	JNZ	GETEXT7
DEF9	EB              	XCHG
DEFA	22 88 DC        	SHLD	INPOINT	;save input line pointer.
DEFD	E1              	POP	H
	                ;
	                ;   Check to see if this is an ambigeous file name specification.
	                ; Set the (A) register to non zero if it is.
	                ;
DEFE	01 0B 00        	LXI	B,11	;set name length.
DF01	23              GETEXT8	INX	H
DF02	7E              	MOV	A,M
DF03	FE 3F           	CPI	'?'	;any question marks?
DF05	C2 09 DF        	JNZ	GETEXT9
DF08	04              	INR	B	;count them.
DF09	0D              GETEXT9	DCR	C
DF0A	C2 01 DF        	JNZ	GETEXT8
DF0D	78              	MOV	A,B
DF0E	B7              	ORA	A
DF0F	C9              	RET
	                ;
	                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
	                ;
	                NUMCMDS	EQU	6	;number of commands
DF10	44 49 52 20     CMDTBL	DB	'DIR '
DF14	45 52 41 20     	DB	'ERA '
DF18	54 59 50 45     	DB	'TYPE'
DF1C	53 41 56 45     	DB	'SAVE'
DF20	52 45 4E 20     	DB	'REN '
DF24	55 53 45 52     	DB	'USER'
	                ;
	                ;   The following six bytes must agree with those at (PATTRN2)
	                ; or cp/m will HALT. Why?
	                ;
DF28	00 16 00 00     PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
	. . .
DF2C	00 00 

	                ;
	                ;   Search the command table for a match with what has just
	                ; been entered. If a match is found, then we jump to the
	                ; proper section. Else jump to (UNKNOWN).
	                ; On return, the (C) register is set to the command number
	                ; that matched (or NUMCMDS+1 if no match).
	                ;
DF2E	21 10 DF        SEARCH	LXI	H,CMDTBL
DF31	0E 00           	MVI	C,0
DF33	79              SEARCH1	MOV	A,C
DF34	FE 06           	CPI	NUMCMDS	;this commands exists.
DF36	D0              	RNC
DF37	11 CE E3        	LXI	D,FCB+1	;check this one.
DF3A	06 04           	MVI	B,4	;max command length.
DF3C	1A              SEARCH2	LDAX	D
DF3D	BE              	CMP	M
DF3E	C2 4F DF        	JNZ	SEARCH3	;not a match.
DF41	13              	INX	D
DF42	23              	INX	H
DF43	05              	DCR	B
DF44	C2 3C DF        	JNZ	SEARCH2
DF47	1A              	LDAX	D	;allow a 3 character command to match.
DF48	FE 20           	CPI	' '
DF4A	C2 54 DF        	JNZ	SEARCH4
DF4D	79              	MOV	A,C	;set return register for this command.
DF4E	C9              	RET
DF4F	23              SEARCH3	INX	H
DF50	05              	DCR	B
DF51	C2 4F DF        	JNZ	SEARCH3
DF54	0C              SEARCH4	INR	C
DF55	C3 33 DF        	JMP	SEARCH1
	                ;
	                ;   Set the input buffer to empty and then start the command
	                ; processor (ccp).
	                ;
DF58	AF              CLEARBUF:XRA	A
DF59	32 07 DC        	STA	INBUFF+1;second byte is actual length.
	                ;
	                ;**************************************************************
	                ;*
	                ;*
	                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
	                ;*
	                ;**************************************************************
	                ;*
DF5C	31 AB E3        COMMAND	LXI	SP,CCPSTACK;setup stack area.
DF5F	C5              	PUSH	B	;note that (C) should be equal to:
DF60	79              	MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
DF61	1F              	RAR		;and 'dddd' is the drive number.
DF62	1F              	RAR
DF63	1F              	RAR
DF64	1F              	RAR
DF65	E6 0F           	ANI	0FH	;isolate the user number.
DF67	5F              	MOV	E,A
DF68	CD 15 DD        	CALL	GETSETUC;and set it.
DF6B	CD B8 DC        	CALL	RESDSK	;reset the disk system.
DF6E	32 AB E3        	STA	BATCH	;clear batch mode flag.
DF71	C1              	POP	B
DF72	79              	MOV	A,C
DF73	E6 0F           	ANI	0FH	;isolate the drive number.
DF75	32 EF E3        	STA	CDRIVE	;and save.
DF78	CD BD DC        	CALL	DSKSEL	;...and select.
DF7B	3A 07 DC        	LDA	INBUFF+1
DF7E	B7              	ORA	A	;anything in input buffer already?
DF7F	C2 98 DF        	JNZ	CMMND2	;yes, we just process it.
	                ;
	                ;   Entry point to get a command line from the console.
	                ;
DF82	31 AB E3        CMMND1	LXI	SP,CCPSTACK;set stack straight.
DF85	CD 98 DC        	CALL	CRLF	;start a new line on the screen.
DF88	CD D0 DD        	CALL	GETDSK	;get current drive.
DF8B	C6 61           	ADI	'a'
DF8D	CD 8C DC        	CALL	PRINT	;print current drive.
DF90	3E 3E           	MVI	A,'>'
DF92	CD 8C DC        	CALL	PRINT	;and add prompt.
DF95	CD 39 DD        	CALL	GETINP	;get line from user.
	                ;
	                ;   Process command line here.
	                ;
DF98	11 80 00        CMMND2	LXI	D,TBUFF
DF9B	CD D8 DD        	CALL	DMASET	;set standard dma address.
DF9E	CD D0 DD        	CALL	GETDSK
DFA1	32 EF E3        	STA	CDRIVE	;set current drive.
DFA4	CD 5E DE        	CALL	CONVFST	;convert name typed in.
DFA7	C4 09 DE        	CNZ	SYNERR	;wild cards are not allowed.
DFAA	3A F0 E3        	LDA	CHGDRV	;if a change in drives was indicated,
DFAD	B7              	ORA	A	;then treat this as an unknown command
DFAE	C2 A5 E2        	JNZ	UNKNOWN	;which gets executed.
DFB1	CD 2E DF        	CALL	SEARCH	;else search command table for a match.
	                ;
	                ;   Note that an unknown command returns
	                ; with (A) pointing to the last address
	                ; in our table which is (UNKNOWN).
	                ;
DFB4	21 C1 DF        	LXI	H,CMDADR;now, look thru our address table for command (A).
DFB7	5F              	MOV	E,A	;set (DE) to command number.
DFB8	16 00           	MVI	D,0
DFBA	19              	DAD	D
DFBB	19              	DAD	D	;(HL)=(CMDADR)+2*(command number).
DFBC	7E              	MOV	A,M	;now pick out this address.
DFBD	23              	INX	H
DFBE	66              	MOV	H,M
DFBF	6F              	MOV	L,A
DFC0	E9              	PCHL		;now execute it.
	                ;
	                ;   CP/M command address table.
	                ;
DFC1	77 E0 1F E1     CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
	. . .
DFC5	5D E1 AD E1 

DFC9	10 E2 8E E2     	DW	RENAME,USER,UNKNOWN
	. . .
DFCD	A5 E2 

	                ;
	                ;   Halt the system. Reason for this is unknown at present.
	                ;
DFCF	21 F3 76        HALT	LXI	H,76F3H	;'DI HLT' instructions.
DFD2	22 00 DC        	SHLD	CBASE
DFD5	21 00 DC        	LXI	H,CBASE
DFD8	E9              	PCHL
	                ;
	                ;   Read error while TYPEing a file.
	                ;
DFD9	01 DF DF        RDERROR	LXI	B,RDERR
DFDC	C3 A7 DC        	JMP	PLINE
DFDF	52 65 61 64     RDERR	DB	'Read error',0
	. . .
DFE7	6F 72 00 

	                ;
	                ;   Required file was not located.
	                ;
DFEA	01 F0 DF        NONE	LXI	B,NOFILE
DFED	C3 A7 DC        	JMP	PLINE
DFF0	4E 6F 20 66     NOFILE	DB	'No file',0
	. . .
DFF4	69 6C 65 00 

	                ;
	                ;   Decode a command of the form 'A>filename number{ filename}.
	                ; Note that a drive specifier is not allowed on the first file
	                ; name. On return, the number is in register (A). Any error
	                ; causes 'filename?' to be printed and the command is aborted.
	                ;
DFF8	CD 5E DE        DECODE	CALL	CONVFST	;convert filename.
DFFB	3A F0 E3        	LDA	CHGDRV	;do not allow a drive to be specified.
DFFE	B7              	ORA	A
DFFF	C2 09 DE        	JNZ	SYNERR
E002	21 CE E3        	LXI	H,FCB+1	;convert number now.
E005	01 0B 00        	LXI	B,11	;(B)=sum register, (C)=max digit count.
E008	7E              DECODE1	MOV	A,M
E009	FE 20           	CPI	' '	;a space terminates the numeral.
E00B	CA 33 E0        	JZ	DECODE3
E00E	23              	INX	H
E00F	D6 30           	SUI	'0'	;make binary from ascii.
E011	FE 0A           	CPI	10	;legal digit?
E013	D2 09 DE        	JNC	SYNERR
E016	57              	MOV	D,A	;yes, save it in (D).
E017	78              	MOV	A,B	;compute (B)=(B)*10 and check for overflow.
E018	E6 E0           	ANI	0E0H
E01A	C2 09 DE        	JNZ	SYNERR
E01D	78              	MOV	A,B
E01E	07              	RLC
E01F	07              	RLC
E020	07              	RLC	;(A)=(B)*8
E021	80              	ADD	B	;.......*9
E022	DA 09 DE        	JC	SYNERR
E025	80              	ADD	B	;.......*10
E026	DA 09 DE        	JC	SYNERR
E029	82              	ADD	D	;add in new digit now.
E02A	DA 09 DE        DECODE2	JC	SYNERR
E02D	47              	MOV	B,A	;and save result.
E02E	0D              	DCR	C	;only look at 11 digits.
E02F	C2 08 E0        	JNZ	DECODE1
E032	C9              	RET
E033	7E              DECODE3	MOV	A,M	;spaces must follow (why?).
E034	FE 20           	CPI	' '
E036	C2 09 DE        	JNZ	SYNERR
E039	23              	INX	H
E03A	0D              DECODE4	DCR	C
E03B	C2 33 E0        	JNZ	DECODE3
E03E	78              	MOV	A,B	;set (A)=the numeric value entered.
E03F	C9              	RET
	                ;
	                ;   Move 3 bytes from (HL) to (DE). Note that there is only
	                ; one reference to this at (A2D5h).
	                ;
E040	06 03           MOVE3	MVI	B,3
	                ;
	                ;   Move (B) bytes from (HL) to (DE).
	                ;
E042	7E              HL2DE	MOV	A,M
E043	12              	STAX	D
E044	23              	INX	H
E045	13              	INX	D
E046	05              	DCR	B
E047	C2 42 E0        	JNZ	HL2DE
E04A	C9              	RET
	                ;
	                ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
	                ;
E04B	21 80 00        EXTRACT	LXI	H,TBUFF
E04E	81              	ADD	C
E04F	CD 59 DE        	CALL	ADDHL
E052	7E              	MOV	A,M
E053	C9              	RET
	                ;
	                ;  Check drive specified. If it means a change, then the new
	                ; drive will be selected. In any case, the drive byte of the
	                ; fcb will be set to null (means use current drive).
	                ;
E054	AF              DSELECT	XRA	A	;null out first byte of fcb.
E055	32 CD E3        	STA	FCB
E058	3A F0 E3        	LDA	CHGDRV	;a drive change indicated?
E05B	B7              	ORA	A
E05C	C8              	RZ
E05D	3D              	DCR	A	;yes, is it the same as the current drive?
E05E	21 EF E3        	LXI	H,CDRIVE
E061	BE              	CMP	M
E062	C8              	RZ
E063	C3 BD DC        	JMP	DSKSEL	;no. Select it then.
	                ;
	                ;   Check the drive selection and reset it to the previous
	                ; drive if it was changed for the preceeding command.
	                ;
E066	3A F0 E3        RESETDR	LDA	CHGDRV	;drive change indicated?
E069	B7              	ORA	A
E06A	C8              	RZ
E06B	3D              	DCR	A	;yes, was it a different drive?
E06C	21 EF E3        	LXI	H,CDRIVE
E06F	BE              	CMP	M
E070	C8              	RZ
E071	3A EF E3        	LDA	CDRIVE	;yes, re-select our old drive.
E074	C3 BD DC        	JMP	DSKSEL
	                ;
	                ;**************************************************************
	                ;*
	                ;*           D I R E C T O R Y   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E077	CD 5E DE        DIRECT	CALL	CONVFST	;convert file name.
E07A	CD 54 E0        	CALL	DSELECT	;select indicated drive.
E07D	21 CE E3        	LXI	H,FCB+1	;was any file indicated?
E080	7E              	MOV	A,M
E081	FE 20           	CPI	' '
E083	C2 8F E0        	JNZ	DIRECT2
E086	06 0B           	MVI	B,11	;no. Fill field with '?' - same as *.*.
E088	36 3F           DIRECT1	MVI	M,'?'
E08A	23              	INX	H
E08B	05              	DCR	B
E08C	C2 88 E0        	JNZ	DIRECT1
E08F	1E 00           DIRECT2	MVI	E,0	;set initial cursor position.
E091	D5              	PUSH	D
E092	CD E9 DC        	CALL	SRCHFCB	;get first file name.
E095	CC EA DF        	CZ	NONE	;none found at all?
E098	CA 1B E1        DIRECT3	JZ	DIRECT9	;terminate if no more names.
E09B	3A EE E3        	LDA	RTNCODE	;get file's position in segment (0-3).
E09E	0F              	RRC
E09F	0F              	RRC
E0A0	0F              	RRC
E0A1	E6 60           	ANI	60H	;(A)=position*32
E0A3	4F              	MOV	C,A
E0A4	3E 0A           	MVI	A,10
E0A6	CD 4B E0        	CALL	EXTRACT	;extract the tenth entry in fcb.
E0A9	17              	RAL		;check system file status bit.
E0AA	DA 0F E1        	JC	DIRECT8	;we don't list them.
E0AD	D1              	POP	D
E0AE	7B              	MOV	A,E	;bump name count.
E0AF	1C              	INR	E
E0B0	D5              	PUSH	D
E0B1	E6 03           	ANI	03H	;at end of line?
E0B3	F5              	PUSH	PSW
E0B4	C2 CC E0        	JNZ	DIRECT4
E0B7	CD 98 DC        	CALL	CRLF	;yes, end this line and start another.
E0BA	C5              	PUSH	B
E0BB	CD D0 DD        	CALL	GETDSK	;start line with ('A:').
E0BE	C1              	POP	B
E0BF	C6 41           	ADI	'A'
E0C1	CD 92 DC        	CALL	PRINTB
E0C4	3E 3A           	MVI	A,':'
E0C6	CD 92 DC        	CALL	PRINTB
E0C9	C3 D4 E0        	JMP	DIRECT5
E0CC	CD A2 DC        DIRECT4	CALL	SPACE	;add seperator between file names.
E0CF	3E 3A           	MVI	A,':'
E0D1	CD 92 DC        	CALL	PRINTB
E0D4	CD A2 DC        DIRECT5	CALL	SPACE
E0D7	06 01           	MVI	B,1	;'extract' each file name character at a time.
E0D9	78              DIRECT6	MOV	A,B
E0DA	CD 4B E0        	CALL	EXTRACT
E0DD	E6 7F           	ANI	7FH	;strip bit 7 (status bit).
E0DF	FE 20           	CPI	' '	;are we at the end of the name?
E0E1	C2 F9 E0        	JNZ	DRECT65
E0E4	F1              	POP	PSW	;yes, don't print spaces at the end of a line.
E0E5	F5              	PUSH	PSW
E0E6	FE 03           	CPI	3
E0E8	C2 F7 E0        	JNZ	DRECT63
E0EB	3E 09           	MVI	A,9	;first check for no extension.
E0ED	CD 4B E0        	CALL	EXTRACT
E0F0	E6 7F           	ANI	7FH
E0F2	FE 20           	CPI	' '
E0F4	CA 0E E1        	JZ	DIRECT7	;don't print spaces.
E0F7	3E 20           DRECT63	MVI	A,' '	;else print them.
E0F9	CD 92 DC        DRECT65	CALL	PRINTB
E0FC	04              	INR	B	;bump to next character psoition.
E0FD	78              	MOV	A,B
E0FE	FE 0C           	CPI	12	;end of the name?
E100	D2 0E E1        	JNC	DIRECT7
E103	FE 09           	CPI	9	;nope, starting extension?
E105	C2 D9 E0        	JNZ	DIRECT6
E108	CD A2 DC        	CALL	SPACE	;yes, add seperating space.
E10B	C3 D9 E0        	JMP	DIRECT6
E10E	F1              DIRECT7	POP	PSW	;get the next file name.
E10F	CD C2 DD        DIRECT8	CALL	CHKCON	;first check console, quit on anything.
E112	C2 1B E1        	JNZ	DIRECT9
E115	CD E4 DC        	CALL	SRCHNXT	;get next name.
E118	C3 98 E0        	JMP	DIRECT3	;and continue with our list.
E11B	D1              DIRECT9	POP	D	;restore the stack and return to command level.
E11C	C3 86 E3        	JMP	GETBACK
	                ;
	                ;**************************************************************
	                ;*
	                ;*                E R A S E   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E11F	CD 5E DE        ERASE	CALL	CONVFST	;convert file name.
E122	FE 0B           	CPI	11	;was '*.*' entered?
E124	C2 42 E1        	JNZ	ERASE1
E127	01 52 E1        	LXI	B,YESNO	;yes, ask for confirmation.
E12A	CD A7 DC        	CALL	PLINE
E12D	CD 39 DD        	CALL	GETINP
E130	21 07 DC        	LXI	H,INBUFF+1
E133	35              	DCR	M	;must be exactly 'y'.
E134	C2 82 DF        	JNZ	CMMND1
E137	23              	INX	H
E138	7E              	MOV	A,M
E139	FE 59           	CPI	'Y'
E13B	C2 82 DF        	JNZ	CMMND1
E13E	23              	INX	H
E13F	22 88 DC        	SHLD	INPOINT	;save input line pointer.
E142	CD 54 E0        ERASE1	CALL	DSELECT	;select desired disk.
E145	11 CD E3        	LXI	D,FCB
E148	CD EF DC        	CALL	DELETE	;delete the file.
E14B	3C              	INR	A
E14C	CC EA DF        	CZ	NONE	;not there?
E14F	C3 86 E3        	JMP	GETBACK	;return to command level now.
E152	41 6C 6C 20     YESNO	DB	'All (y/n)?',0
	. . .
E15A	29 3F 00 

	                ;
	                ;**************************************************************
	                ;*
	                ;*            T Y P E   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E15D	CD 5E DE        TYPE	CALL	CONVFST	;convert file name.
E160	C2 09 DE        	JNZ	SYNERR	;wild cards not allowed.
E163	CD 54 E0        	CALL	DSELECT	;select indicated drive.
E166	CD D0 DC        	CALL	OPENFCB	;open the file.
E169	CA A7 E1        	JZ	TYPE5	;not there?
E16C	CD 98 DC        	CALL	CRLF	;ok, start a new line on the screen.
E16F	21 F1 E3        	LXI	H,NBYTES;initialize byte counter.
E172	36 FF           	MVI	M,0FFH	;set to read first sector.
E174	21 F1 E3        TYPE1	LXI	H,NBYTES
E177	7E              TYPE2	MOV	A,M	;have we written the entire sector?
E178	FE 80           	CPI	128
E17A	DA 87 E1        	JC	TYPE3
E17D	E5              	PUSH	H	;yes, read in the next one.
E17E	CD FE DC        	CALL	READFCB
E181	E1              	POP	H
E182	C2 A0 E1        	JNZ	TYPE4	;end or error?
E185	AF              	XRA	A	;ok, clear byte counter.
E186	77              	MOV	M,A
E187	34              TYPE3	INR	M	;count this byte.
E188	21 80 00        	LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
E18B	CD 59 DE        	CALL	ADDHL
E18E	7E              	MOV	A,M
E18F	FE 1A           	CPI	CNTRLZ	;end of file mark?
E191	CA 86 E3        	JZ	GETBACK
E194	CD 8C DC        	CALL	PRINT	;no, print it.
E197	CD C2 DD        	CALL	CHKCON	;check console, quit if anything ready.
E19A	C2 86 E3        	JNZ	GETBACK
E19D	C3 74 E1        	JMP	TYPE1
	                ;
	                ;   Get here on an end of file or read error.
	                ;
E1A0	3D              TYPE4	DCR	A	;read error?
E1A1	CA 86 E3        	JZ	GETBACK
E1A4	CD D9 DF        	CALL	RDERROR	;yes, print message.
E1A7	CD 66 E0        TYPE5	CALL	RESETDR	;and reset proper drive
E1AA	C3 09 DE        	JMP	SYNERR	;now print file name with problem.
	                ;
	                ;**************************************************************
	                ;*
	                ;*            S A V E   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E1AD	CD F8 DF        SAVE	CALL	DECODE	;get numeric number that follows SAVE.
E1B0	F5              	PUSH	PSW	;save number of pages to write.
E1B1	CD 5E DE        	CALL	CONVFST	;convert file name.
E1B4	C2 09 DE        	JNZ	SYNERR	;wild cards not allowed.
E1B7	CD 54 E0        	CALL	DSELECT	;select specified drive.
E1BA	11 CD E3        	LXI	D,FCB	;now delete this file.
E1BD	D5              	PUSH	D
E1BE	CD EF DC        	CALL	DELETE
E1C1	D1              	POP	D
E1C2	CD 09 DD        	CALL	CREATE	;and create it again.
E1C5	CA FB E1        	JZ	SAVE3	;can't create?
E1C8	AF              	XRA	A	;clear record number byte.
E1C9	32 ED E3        	STA	FCB+32
E1CC	F1              	POP	PSW	;convert pages to sectors.
E1CD	6F              	MOV	L,A
E1CE	26 00           	MVI	H,0
E1D0	29              	DAD	H	;(HL)=number of sectors to write.
E1D1	11 00 01        	LXI	D,TBASE	;and we start from here.
E1D4	7C              SAVE1	MOV	A,H	;done yet?
E1D5	B5              	ORA	L
E1D6	CA F1 E1        	JZ	SAVE2
E1D9	2B              	DCX	H	;nope, count this and compute the start
E1DA	E5              	PUSH	H	;of the next 128 byte sector.
E1DB	21 80 00        	LXI	H,128
E1DE	19              	DAD	D
E1DF	E5              	PUSH	H	;save it and set the transfer address.
E1E0	CD D8 DD        	CALL	DMASET
E1E3	11 CD E3        	LXI	D,FCB	;write out this sector now.
E1E6	CD 04 DD        	CALL	WRTREC
E1E9	D1              	POP	D	;reset (DE) to the start of the last sector.
E1EA	E1              	POP	H	;restore sector count.
E1EB	C2 FB E1        	JNZ	SAVE3	;write error?
E1EE	C3 D4 E1        	JMP	SAVE1
	                ;
	                ;   Get here after writing all of the file.
	                ;
E1F1	11 CD E3        SAVE2	LXI	D,FCB	;now close the file.
E1F4	CD DA DC        	CALL	CLOSE
E1F7	3C              	INR	A	;did it close ok?
E1F8	C2 01 E2        	JNZ	SAVE4
	                ;
	                ;   Print out error message (no space).
	                ;
E1FB	01 07 E2        SAVE3	LXI	B,NOSPACE
E1FE	CD A7 DC        	CALL	PLINE
E201	CD D5 DD        SAVE4	CALL	STDDMA	;reset the standard dma address.
E204	C3 86 E3        	JMP	GETBACK
E207	4E 6F 20 73     NOSPACE	DB	'No space',0
	. . .
E20F	00 

	                ;
	                ;**************************************************************
	                ;*
	                ;*           R E N A M E   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E210	CD 5E DE        RENAME	CALL	CONVFST	;convert first file name.
E213	C2 09 DE        	JNZ	SYNERR	;wild cards not allowed.
E216	3A F0 E3        	LDA	CHGDRV	;remember any change in drives specified.
E219	F5              	PUSH	PSW
E21A	CD 54 E0        	CALL	DSELECT	;and select this drive.
E21D	CD E9 DC        	CALL	SRCHFCB	;is this file present?
E220	C2 79 E2        	JNZ	RENAME6	;yes, print error message.
E223	21 CD E3        	LXI	H,FCB	;yes, move this name into second slot.
E226	11 DD E3        	LXI	D,FCB+16
E229	06 10           	MVI	B,16
E22B	CD 42 E0        	CALL	HL2DE
E22E	2A 88 DC        	LHLD	INPOINT	;get input pointer.
E231	EB              	XCHG
E232	CD 4F DE        	CALL	NONBLANK;get next non blank character.
E235	FE 3D           	CPI	'='	;only allow an '=' or '_' seperator.
E237	CA 3F E2        	JZ	RENAME1
E23A	FE 5F           	CPI	'_'
E23C	C2 73 E2        	JNZ	RENAME5
E23F	EB              RENAME1	XCHG
E240	23              	INX	H	;ok, skip seperator.
E241	22 88 DC        	SHLD	INPOINT	;save input line pointer.
E244	CD 5E DE        	CALL	CONVFST	;convert this second file name now.
E247	C2 73 E2        	JNZ	RENAME5	;again, no wild cards.
E24A	F1              	POP	PSW	;if a drive was specified, then it
E24B	47              	MOV	B,A	;must be the same as before.
E24C	21 F0 E3        	LXI	H,CHGDRV
E24F	7E              	MOV	A,M
E250	B7              	ORA	A
E251	CA 59 E2        	JZ	RENAME2
E254	B8              	CMP	B
E255	70              	MOV	M,B
E256	C2 73 E2        	JNZ	RENAME5	;they were different, error.
E259	70              RENAME2	MOV	M,B;	reset as per the first file specification.
E25A	AF              	XRA	A
E25B	32 CD E3        	STA	FCB	;clear the drive byte of the fcb.
E25E	CD E9 DC        RENAME3	CALL	SRCHFCB	;and go look for second file.
E261	CA 6D E2        	JZ	RENAME4	;doesn't exist?
E264	11 CD E3        	LXI	D,FCB
E267	CD 0E DD        	CALL	RENAM	;ok, rename the file.
E26A	C3 86 E3        	JMP	GETBACK
	                ;
	                ;   Process rename errors here.
	                ;
E26D	CD EA DF        RENAME4	CALL	NONE	;file not there.
E270	C3 86 E3        	JMP	GETBACK
E273	CD 66 E0        RENAME5	CALL	RESETDR	;bad command format.
E276	C3 09 DE        	JMP	SYNERR
E279	01 82 E2        RENAME6	LXI	B,EXISTS;destination file already exists.
E27C	CD A7 DC        	CALL	PLINE
E27F	C3 86 E3        	JMP	GETBACK
E282	46 69 6C 65     EXISTS	DB	'File exists',0
	. . .
E28A	73 74 73 00 

	                ;
	                ;**************************************************************
	                ;*
	                ;*             U S E R   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E28E	CD F8 DF        USER	CALL	DECODE	;get numeric value following command.
E291	FE 10           	CPI	16	;legal user number?
E293	D2 09 DE        	JNC	SYNERR
E296	5F              	MOV	E,A	;yes but is there anything else?
E297	3A CE E3        	LDA	FCB+1
E29A	FE 20           	CPI	' '
E29C	CA 09 DE        	JZ	SYNERR	;yes, that is not allowed.
E29F	CD 15 DD        	CALL	GETSETUC;ok, set user code.
E2A2	C3 89 E3        	JMP	GETBACK1
	                ;
	                ;**************************************************************
	                ;*
	                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
	                ;*
	                ;**************************************************************
	                ;
E2A5	CD F5 DD        UNKNOWN	CALL	VERIFY	;check for valid system (why?).
E2A8	3A CE E3        	LDA	FCB+1	;anything to execute?
E2AB	FE 20           	CPI	' '
E2AD	C2 C4 E2        	JNZ	UNKWN1
E2B0	3A F0 E3        	LDA	CHGDRV	;nope, only a drive change?
E2B3	B7              	ORA	A
E2B4	CA 89 E3        	JZ	GETBACK1;neither???
E2B7	3D              	DCR	A
E2B8	32 EF E3        	STA	CDRIVE	;ok, store new drive.
E2BB	CD 29 DD        	CALL	MOVECD	;set (TDRIVE) also.
E2BE	CD BD DC        	CALL	DSKSEL	;and select this drive.
E2C1	C3 89 E3        	JMP	GETBACK1;then return.
	                ;
	                ;   Here a file name was typed. Prepare to execute it.
	                ;
E2C4	11 D6 E3        UNKWN1	LXI	D,FCB+9	;an extension specified?
E2C7	1A              	LDAX	D
E2C8	FE 20           	CPI	' '
E2CA	C2 09 DE        	JNZ	SYNERR	;yes, not allowed.
E2CD	D5              UNKWN2	PUSH	D
E2CE	CD 54 E0        	CALL	DSELECT	;select specified drive.
E2D1	D1              	POP	D
E2D2	21 83 E3        	LXI	H,COMFILE	;set the extension to 'COM'.
E2D5	CD 40 E0        	CALL	MOVE3
E2D8	CD D0 DC        	CALL	OPENFCB	;and open this file.
E2DB	CA 6B E3        	JZ	UNKWN9	;not present?
	                ;
	                ;   Load in the program.
	                ;
E2DE	21 00 01        	LXI	H,TBASE	;store the program starting here.
E2E1	E5              UNKWN3	PUSH	H
E2E2	EB              	XCHG
E2E3	CD D8 DD        	CALL	DMASET	;set transfer address.
E2E6	11 CD E3        	LXI	D,FCB	;and read the next record.
E2E9	CD F9 DC        	CALL	RDREC
E2EC	C2 01 E3        	JNZ	UNKWN4	;end of file or read error?
E2EF	E1              	POP	H	;nope, bump pointer for next sector.
E2F0	11 80 00        	LXI	D,128
E2F3	19              	DAD	D
E2F4	11 00 DC        	LXI	D,CBASE	;enough room for the whole file?
E2F7	7D              	MOV	A,L
E2F8	93              	SUB	E
E2F9	7C              	MOV	A,H
E2FA	9A              	SBB	D
E2FB	D2 71 E3        	JNC	UNKWN0	;no, it can't fit.
E2FE	C3 E1 E2        	JMP	UNKWN3
	                ;
	                ;   Get here after finished reading.
	                ;
E301	E1              UNKWN4	POP	H
E302	3D              	DCR	A	;normal end of file?
E303	C2 71 E3        	JNZ	UNKWN0
E306	CD 66 E0        	CALL	RESETDR	;yes, reset previous drive.
E309	CD 5E DE        	CALL	CONVFST	;convert the first file name that follows
E30C	21 F0 E3        	LXI	H,CHGDRV;command name.
E30F	E5              	PUSH	H
E310	7E              	MOV	A,M	;set drive code in default fcb.
E311	32 CD E3        	STA	FCB
E314	3E 10           	MVI	A,16	;put second name 16 bytes later.
E316	CD 60 DE        	CALL	CONVERT	;convert second file name.
E319	E1              	POP	H
E31A	7E              	MOV	A,M	;and set the drive for this second file.
E31B	32 DD E3        	STA	FCB+16
E31E	AF              	XRA	A	;clear record byte in fcb.
E31F	32 ED E3        	STA	FCB+32
E322	11 5C 00        	LXI	D,TFCB	;move it into place at(005Ch).
E325	21 CD E3        	LXI	H,FCB
E328	06 21           	MVI	B,33
E32A	CD 42 E0        	CALL	HL2DE
E32D	21 08 DC        	LXI	H,INBUFF+2;now move the remainder of the input
E330	7E              UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
E331	B7              	ORA	A	;or a null.
E332	CA 3E E3        	JZ	UNKWN6
E335	FE 20           	CPI	' '
E337	CA 3E E3        	JZ	UNKWN6
E33A	23              	INX	H
E33B	C3 30 E3        	JMP	UNKWN5
	                ;
	                ;   Do the line move now. It ends in a null byte.
	                ;
E33E	06 00           UNKWN6	MVI	B,0	;keep a character count.
E340	11 81 00        	LXI	D,TBUFF+1;data gets put here.
E343	7E              UNKWN7	MOV	A,M	;move it now.
E344	12              	STAX	D
E345	B7              	ORA	A
E346	CA 4F E3        	JZ	UNKWN8
E349	04              	INR	B
E34A	23              	INX	H
E34B	13              	INX	D
E34C	C3 43 E3        	JMP	UNKWN7
E34F	78              UNKWN8	MOV	A,B	;now store the character count.
E350	32 80 00        	STA	TBUFF
E353	CD 98 DC        	CALL	CRLF	;clean up the screen.
E356	CD D5 DD        	CALL	STDDMA	;set standard transfer address.
E359	CD 1A DD        	CALL	SETCDRV	;reset current drive.
E35C	CD 00 01        	CALL	TBASE	;and execute the program.
	                ;
	                ;   Transiant programs return here (or reboot).
	                ;
E35F	31 AB E3        	LXI	SP,BATCH	;set stack first off.
E362	CD 29 DD        	CALL	MOVECD	;move current drive into place (TDRIVE).
E365	CD BD DC        	CALL	DSKSEL	;and reselect it.
E368	C3 82 DF        	JMP	CMMND1	;back to comand mode.
	                ;
	                ;   Get here if some error occured.
	                ;
E36B	CD 66 E0        UNKWN9	CALL	RESETDR	;inproper format.
E36E	C3 09 DE        	JMP	SYNERR
E371	01 7A E3        UNKWN0	LXI	B,BADLOAD;read error or won't fit.
E374	CD A7 DC        	CALL	PLINE
E377	C3 86 E3        	JMP	GETBACK
E37A	42 61 64 20     BADLOAD	DB	'Bad load',0
	. . .
E382	00 

E383	43 4F 4D        COMFILE	DB	'COM'	;command file extension.
	                ;
	                ;   Get here to return to command level. We will reset the
	                ; previous active drive and then either return to command
	                ; level directly or print error message and then return.
	                ;
E386	CD 66 E0        GETBACK	CALL	RESETDR	;reset previous drive.
E389	CD 5E DE        GETBACK1:CALL	CONVFST	;convert first name in (FCB).
E38C	3A CE E3        	LDA	FCB+1	;if this was just a drive change request,
E38F	D6 20           	SUI	' '	;make sure it was valid.
E391	21 F0 E3        	LXI	H,CHGDRV
E394	B6              	ORA	M
E395	C2 09 DE        	JNZ	SYNERR
E398	C3 82 DF        	JMP	CMMND1	;ok, return to command level.
	                ;
	                ;   ccp stack area.
	                ;
E39B	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
E3A7	00 00 00 00 

	                CCPSTACK:EQU	$	;end of ccp stack area.
	                ;
	                ;   Batch (or SUBMIT) processing information storage.
	                ;
E3AB	00              BATCH	DB	0	;batch mode flag (0=not active).
E3AC	00 24 24 24     BATCHFCB:DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
E3CC	00 

	                ;
	                ;   File control block setup by the CCP.
	                ;
E3CD	00 20 20 20     FCB	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
	. . .
E3ED	00 

E3EE	00              RTNCODE	DB	0	;status returned from bdos call.
E3EF	00              CDRIVE	DB	0	;currently active drive.
E3F0	00              CHGDRV	DB	0	;change in drives flag (0=no change).
E3F1	00 00           NBYTES	DW	0	;byte counter used by TYPE.
	                ;
	                ;   Room for expansion?
	                ;
E3F3	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
E3FF	00 

	                ;
	                ;   Note that the following six bytes must match those at
	                ; (PATTRN1) or cp/m will HALT. Why?
	                ;
E400	00 16 00 00     PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
	. . .
E404	00 00 

	                ;
	                ;**************************************************************
	                ;*
	                ;*                    B D O S   E N T R Y
	                ;*
	                ;**************************************************************
	                ;
E406	C3 11 E4        FBASE	JMP	FBASE1
	                ;
	                ;   Bdos error table.
	                ;
E409	99 E4           BADSCTR	DW	ERROR1	;bad sector on read or write.
E40B	A5 E4           BADSLCT	DW	ERROR2	;bad disk select.
E40D	AB E4           RODISK	DW	ERROR3	;disk is read only.
E40F	B1 E4           ROFILE	DW	ERROR4	;file is read only.
	                ;
	                ;   Entry into bdos. (DE) or (E) are the parameters passed. The
	                ; function number desired is in register (C).
	                ;
E411	EB              FBASE1	XCHG		;save the (DE) parameters.
E412	22 43 E7        	SHLD	PARAMS
E415	EB              	XCHG
E416	7B              	MOV	A,E	;and save register (E) in particular.
E417	32 D6 F1        	STA	EPARAM
E41A	21 00 00        	LXI	H,0
E41D	22 45 E7        	SHLD	STATUS	;clear return status.
E420	39              	DAD	SP
E421	22 0F E7        	SHLD	USRSTACK;save users stack pointer.
E424	31 41 E7        	LXI	SP,STKAREA;and set our own.
E427	AF              	XRA	A	;clear auto select storage space.
E428	32 E0 F1        	STA	AUTOFLAG
E42B	32 DE F1        	STA	AUTO
E42E	21 74 F1        	LXI	H,GOBACK;set return address.
E431	E5              	PUSH	H
E432	79              	MOV	A,C	;get function number.
E433	FE 29           	CPI	NFUNCTS	;valid function number?
E435	D0              	RNC
E436	4B              	MOV	C,E	;keep single register function here.
E437	21 47 E4        	LXI	H,FUNCTNS;now look thru the function table.
E43A	5F              	MOV	E,A
E43B	16 00           	MVI	D,0	;(DE)=function number.
E43D	19              	DAD	D
E43E	19              	DAD	D	;(HL)=(start of table)+2*(function number).
E43F	5E              	MOV	E,M
E440	23              	INX	H
E441	56              	MOV	D,M	;now (DE)=address for this function.
E442	2A 43 E7        	LHLD	PARAMS	;retrieve parameters.
E445	EB              	XCHG		;now (DE) has the original parameters.
E446	E9              	PCHL		;execute desired function.
	                ;
	                ;   BDOS function jump table.
	                ;
	                NFUNCTS	EQU	41	;number of functions in followin table.
	                ;
E447	03 F2 C8 E6     FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
	. . .
E453	D4 E6 ED E6 

E457	F3 E6 F8 E6     	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
	. . .
E463	45 F0 9C F0 

E467	A5 F0 AB F0     	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
	. . .
E473	EC F0 

E475	F5 F0 FE F0     	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
	. . .
E481	17 F1 1D F1 

E485	26 F1 2D F1     	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
	. . .
E491	53 F1 04 E7 

E495	04 E7 9B F1     	DW	RTN,WTSPECL
	                ;
	                ;   Bdos error message section.
	                ;
E499	21 CA E4        ERROR1	LXI	H,BADSEC	;bad sector message.
E49C	CD E5 E4        	CALL	PRTERR	;print it and get a 1 char responce.
E49F	FE 03           	CPI	CNTRLC	;re-boot request (control-c)?
E4A1	CA 00 00        	JZ	0	;yes.
E4A4	C9              	RET		;no, return to retry i/o function.
	                ;
E4A5	21 D5 E4        ERROR2	LXI	H,BADSEL	;bad drive selected.
E4A8	C3 B4 E4        	JMP	ERROR5
	                ;
E4AB	21 E1 E4        ERROR3	LXI	H,DISKRO	;disk is read only.
E4AE	C3 B4 E4        	JMP	ERROR5
	                ;
E4B1	21 DC E4        ERROR4	LXI	H,FILERO	;file is read only.
	                ;
E4B4	CD E5 E4        ERROR5	CALL	PRTERR
E4B7	C3 00 00        	JMP	0	;always reboot on these errors.
	                ;
E4BA	42 64 6F 73     BDOSERR	DB	'Bdos Err On '
	. . .
E4C2	20 4F 6E 20 

E4C6	20 3A 20 24     BDOSDRV	DB	' : $'
E4CA	42 61 64 20     BADSEC	DB	'Bad Sector$'
	. . .
E4D2	6F 72 24 

E4D5	53 65 6C 65     BADSEL	DB	'Select$'
	. . .
E4D9	63 74 24 

E4DC	46 69 6C 65     FILERO	DB	'File '
	. . .
E4E0	20 

E4E1	52 2F 4F 24     DISKRO	DB	'R/O$'
	                ;
	                ;   Print bdos error message.
	                ;
E4E5	E5              PRTERR	PUSH	H	;save second message pointer.
E4E6	CD C9 E5        	CALL	OUTCRLF	;send (cr)(lf).
E4E9	3A 42 E7        	LDA	ACTIVE	;get active drive.
E4EC	C6 41           	ADI	'A'	;make ascii.
E4EE	32 C6 E4        	STA	BDOSDRV	;and put in message.
E4F1	01 BA E4        	LXI	B,BDOSERR;and print it.
E4F4	CD D3 E5        	CALL	PRTMESG
E4F7	C1              	POP	B	;print second message line now.
E4F8	CD D3 E5        	CALL	PRTMESG
	                ;
	                ;   Get an input character. We will check our 1 character
	                ; buffer first. This may be set by the console status routine.
	                ;
E4FB	21 0E E7        GETCHAR	LXI	H,CHARBUF;check character buffer.
E4FE	7E              	MOV	A,M	;anything present already?
E4FF	36 00           	MVI	M,0	;...either case clear it.
E501	B7              	ORA	A
E502	C0              	RNZ		;yes, use it.
E503	C3 09 F2        	JMP	CONIN	;nope, go get a character responce.
	                ;
	                ;   Input and echo a character.
	                ;
E506	CD FB E4        GETECHO	CALL	GETCHAR	;input a character.
E509	CD 14 E5        	CALL	CHKCHAR	;carriage control?
E50C	D8              	RC		;no, a regular control char so don't echo.
E50D	F5              	PUSH	PSW	;ok, save character now.
E50E	4F              	MOV	C,A
E50F	CD 90 E5        	CALL	OUTCON	;and echo it.
E512	F1              	POP	PSW	;get character and return.
E513	C9              	RET
	                ;
	                ;   Check character in (A). Set the zero flag on a carriage
	                ; control character and the carry flag on any other control
	                ; character.
	                ;
E514	FE 0D           CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
E516	C8              	RZ		;or a tab.
E517	FE 0A           	CPI	LF
E519	C8              	RZ
E51A	FE 09           	CPI	TAB
E51C	C8              	RZ
E51D	FE 08           	CPI	BS
E51F	C8              	RZ
E520	FE 20           	CPI	' '	;other control char? Set carry flag.
E522	C9              	RET
	                ;
	                ;   Check the console during output. Halt on a control-s, then
	                ; reboot on a control-c. If anything else is ready, clear the
	                ; zero flag and return (the calling routine may want to do
	                ; something).
	                ;
E523	3A 0E E7        CKCONSOL:LDA	CHARBUF	;check buffer.
E526	B7              	ORA	A	;if anything, just return without checking.
E527	C2 45 E5        	JNZ	CKCON2
E52A	CD 06 F2        	CALL	CONST	;nothing in buffer. Check console.
E52D	E6 01           	ANI	01H	;look at bit 0.
E52F	C8              	RZ		;return if nothing.
E530	CD 09 F2        	CALL	CONIN	;ok, get it.
E533	FE 13           	CPI	CNTRLS	;if not control-s, return with zero cleared.
E535	C2 42 E5        	JNZ	CKCON1
E538	CD 09 F2        	CALL	CONIN	;halt processing until another char
E53B	FE 03           	CPI	CNTRLC	;is typed. Control-c?
E53D	CA 00 00        	JZ	0	;yes, reboot now.
E540	AF              	XRA	A	;no, just pretend nothing was ever ready.
E541	C9              	RET
E542	32 0E E7        CKCON1	STA	CHARBUF	;save character in buffer for later processing.
E545	3E 01           CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
E547	C9              	RET
	                ;
	                ;   Output (C) to the screen. If the printer flip-flop flag
	                ; is set, we will send character to printer also. The console
	                ; will be checked in the process.
	                ;
E548	3A 0A E7        OUTCHAR	LDA	OUTFLAG	;check output flag.
E54B	B7              	ORA	A	;anything and we won't generate output.
E54C	C2 62 E5        	JNZ	OUTCHR1
E54F	C5              	PUSH	B
E550	CD 23 E5        	CALL	CKCONSOL;check console (we don't care whats there).
E553	C1              	POP	B
E554	C5              	PUSH	B
E555	CD 0C F2        	CALL	CONOUT	;output (C) to the screen.
E558	C1              	POP	B
E559	C5              	PUSH	B
E55A	3A 0D E7        	LDA	PRTFLAG	;check printer flip-flop flag.
E55D	B7              	ORA	A
E55E	C4 0F F2        	CNZ	LIST	;print it also if non-zero.
E561	C1              	POP	B
E562	79              OUTCHR1	MOV	A,C	;update cursors position.
E563	21 0C E7        	LXI	H,CURPOS
E566	FE 7F           	CPI	DEL	;rubouts don't do anything here.
E568	C8              	RZ
E569	34              	INR	M	;bump line pointer.
E56A	FE 20           	CPI	' '	;and return if a normal character.
E56C	D0              	RNC
E56D	35              	DCR	M	;restore and check for the start of the line.
E56E	7E              	MOV	A,M
E56F	B7              	ORA	A
E570	C8              	RZ		;ingnore control characters at the start of the line.
E571	79              	MOV	A,C
E572	FE 08           	CPI	BS	;is it a backspace?
E574	C2 79 E5        	JNZ	OUTCHR2
E577	35              	DCR	M	;yes, backup pointer.
E578	C9              	RET
E579	FE 0A           OUTCHR2	CPI	LF	;is it a line feed?
E57B	C0              	RNZ		;ignore anything else.
E57C	36 00           	MVI	M,0	;reset pointer to start of line.
E57E	C9              	RET
	                ;
	                ;   Output (A) to the screen. If it is a control character
	                ; (other than carriage control), use ^x format.
	                ;
E57F	79              SHOWIT	MOV	A,C
E580	CD 14 E5        	CALL	CHKCHAR	;check character.
E583	D2 90 E5        	JNC	OUTCON	;not a control, use normal output.
E586	F5              	PUSH	PSW
E587	0E 5E           	MVI	C,'^'	;for a control character, preceed it with '^'.
E589	CD 48 E5        	CALL	OUTCHAR
E58C	F1              	POP	PSW
E58D	F6 40           	ORI	'@'	;and then use the letter equivelant.
E58F	4F              	MOV	C,A
	                ;
	                ;   Function to output (C) to the console device and expand tabs
	                ; if necessary.
	                ;
E590	79              OUTCON	MOV	A,C
E591	FE 09           	CPI	TAB	;is it a tab?
E593	C2 48 E5        	JNZ	OUTCHAR	;use regular output.
E596	0E 20           OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
E598	CD 48 E5        	CALL	OUTCHAR
E59B	3A 0C E7        	LDA	CURPOS	;go until the cursor is at a multiple of 8
	                
E59E	E6 07           	ANI	07H	;position.
E5A0	C2 96 E5        	JNZ	OUTCON1
E5A3	C9              	RET
	                ;
	                ;   Echo a backspace character. Erase the prevoius character
	                ; on the screen.
	                ;
E5A4	CD AC E5        BACKUP	CALL	BACKUP1	;backup the screen 1 place.
E5A7	0E 20           	MVI	C,' '	;then blank that character.
E5A9	CD 0C F2        	CALL	CONOUT
E5AC	0E 08           BACKUP1	MVI	C,BS	;then back space once more.
E5AE	C3 0C F2        	JMP	CONOUT
	                ;
	                ;   Signal a deleted line. Print a '#' at the end and start
	                ; over.
	                ;
E5B1	0E 23           NEWLINE	MVI	C,'#'
E5B3	CD 48 E5        	CALL	OUTCHAR	;print this.
E5B6	CD C9 E5        	CALL	OUTCRLF	;start new line.
E5B9	3A 0C E7        NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
E5BC	21 0B E7        	LXI	H,STARTING
E5BF	BE              	CMP	M
E5C0	D0              	RNC		;there yet?
E5C1	0E 20           	MVI	C,' '
E5C3	CD 48 E5        	CALL	OUTCHAR	;nope, keep going.
E5C6	C3 B9 E5        	JMP	NEWLN1
	                ;
	                ;   Output a (cr) (lf) to the console device (screen).
	                ;
E5C9	0E 0D           OUTCRLF	MVI	C,CR
E5CB	CD 48 E5        	CALL	OUTCHAR
E5CE	0E 0A           	MVI	C,LF
E5D0	C3 48 E5        	JMP	OUTCHAR
	                ;
	                ;   Print message pointed to by (BC). It will end with a '$'.
	                ;
E5D3	0A              PRTMESG	LDAX	B	;check for terminating character.
E5D4	FE 24           	CPI	'$'
E5D6	C8              	RZ
E5D7	03              	INX	B
E5D8	C5              	PUSH	B	;otherwise, bump pointer and print it.
E5D9	4F              	MOV	C,A
E5DA	CD 90 E5        	CALL	OUTCON
E5DD	C1              	POP	B
E5DE	C3 D3 E5        	JMP	PRTMESG
	                ;
	                ;   Function to execute a buffered read.
	                ;
E5E1	3A 0C E7        RDBUFF	LDA	CURPOS	;use present location as starting one.
E5E4	32 0B E7        	STA	STARTING
E5E7	2A 43 E7        	LHLD	PARAMS	;get the maximum buffer space.
E5EA	4E              	MOV	C,M
E5EB	23              	INX	H	;point to first available space.
E5EC	E5              	PUSH	H	;and save.
E5ED	06 00           	MVI	B,0	;keep a character count.
E5EF	C5              RDBUF1	PUSH	B
E5F0	E5              	PUSH	H
E5F1	CD FB E4        RDBUF2	CALL	GETCHAR	;get the next input character.
E5F4	E6 7F           	ANI	7FH	;strip bit 7.
E5F6	E1              	POP	H	;reset registers.
E5F7	C1              	POP	B
E5F8	FE 0D           	CPI	CR	;en of the line?
E5FA	CA C1 E6        	JZ	RDBUF17
E5FD	FE 0A           	CPI	LF
E5FF	CA C1 E6        	JZ	RDBUF17
E602	FE 08           	CPI	BS	;how about a backspace?
E604	C2 16 E6        	JNZ	RDBUF3
E607	78              	MOV	A,B	;yes, but ignore at the beginning of the line.
E608	B7              	ORA	A
E609	CA EF E5        	JZ	RDBUF1
E60C	05              	DCR	B	;ok, update counter.
E60D	3A 0C E7        	LDA	CURPOS	;if we backspace to the start of the line,
E610	32 0A E7        	STA	OUTFLAG	;treat as a cancel (control-x).
E613	C3 70 E6        	JMP	RDBUF10
E616	FE 7F           RDBUF3	CPI	DEL	;user typed a rubout?
E618	C2 26 E6        	JNZ	RDBUF4
E61B	78              	MOV	A,B	;ignore at the start of the line.
E61C	B7              	ORA	A
E61D	CA EF E5        	JZ	RDBUF1
E620	7E              	MOV	A,M	;ok, echo the prevoius character.
E621	05              	DCR	B	;and reset pointers (counters).
E622	2B              	DCX	H
E623	C3 A9 E6        	JMP	RDBUF15
E626	FE 05           RDBUF4	CPI	CNTRLE	;physical end of line?
E628	C2 37 E6        	JNZ	RDBUF5
E62B	C5              	PUSH	B	;yes, do it.
E62C	E5              	PUSH	H
E62D	CD C9 E5        	CALL	OUTCRLF
E630	AF              	XRA	A	;and update starting position.
E631	32 0B E7        	STA	STARTING
E634	C3 F1 E5        	JMP	RDBUF2
E637	FE 10           RDBUF5	CPI	CNTRLP	;control-p?
E639	C2 48 E6        	JNZ	RDBUF6
E63C	E5              	PUSH	H	;yes, flip the print flag filp-flop byte.
E63D	21 0D E7        	LXI	H,PRTFLAG
E640	3E 01           	MVI	A,1	;PRTFLAG=1-PRTFLAG
E642	96              	SUB	M
E643	77              	MOV	M,A
E644	E1              	POP	H
E645	C3 EF E5        	JMP	RDBUF1
E648	FE 18           RDBUF6	CPI	CNTRLX	;control-x (cancel)?
E64A	C2 5F E6        	JNZ	RDBUF8
E64D	E1              	POP	H
E64E	3A 0B E7        RDBUF7	LDA	STARTING;yes, backup the cursor to here.
E651	21 0C E7        	LXI	H,CURPOS
E654	BE              	CMP	M
E655	D2 E1 E5        	JNC	RDBUFF	;done yet?
E658	35              	DCR	M	;no, decrement pointer and output back up one space.
E659	CD A4 E5        	CALL	BACKUP
E65C	C3 4E E6        	JMP	RDBUF7
E65F	FE 15           RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
E661	C2 6B E6        	JNZ	RDBUF9
E664	CD B1 E5        	CALL	NEWLINE	;start a new line.
E667	E1              	POP	H
E668	C3 E1 E5        	JMP	RDBUFF
E66B	FE 12           RDBUF9	CPI	CNTRLR	;control-r?
E66D	C2 A6 E6        	JNZ	RDBUF14
E670	C5              RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
E671	CD B1 E5        	CALL	NEWLINE
E674	C1              	POP	B
E675	E1              	POP	H
E676	E5              	PUSH	H
E677	C5              	PUSH	B
E678	78              RDBUF11	MOV	A,B	;done whole line yet?
E679	B7              	ORA	A
E67A	CA 8A E6        	JZ	RDBUF12
E67D	23              	INX	H	;nope, get next character.
E67E	4E              	MOV	C,M
E67F	05              	DCR	B	;count it.
E680	C5              	PUSH	B
E681	E5              	PUSH	H
E682	CD 7F E5        	CALL	SHOWIT	;and display it.
E685	E1              	POP	H
E686	C1              	POP	B
E687	C3 78 E6        	JMP	RDBUF11
E68A	E5              RDBUF12	PUSH	H	;done with line. If we were displaying
E68B	3A 0A E7        	LDA	OUTFLAG	;then update cursor position.
E68E	B7              	ORA	A
E68F	CA F1 E5        	JZ	RDBUF2
E692	21 0C E7        	LXI	H,CURPOS;because this line is shorter, we must
E695	96              	SUB	M	;back up the cursor (not the screen however)
E696	32 0A E7        	STA	OUTFLAG	;some number of positions.
E699	CD A4 E5        RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
E69C	21 0A E7        	LXI	H,OUTFLAG;zero, the screen will not be changed.
E69F	35              	DCR	M
E6A0	C2 99 E6        	JNZ	RDBUF13
E6A3	C3 F1 E5        	JMP	RDBUF2	;now just get the next character.
	                ;
	                ;   Just a normal character, put this in our buffer and echo.
	                ;
E6A6	23              RDBUF14	INX	H
E6A7	77              	MOV	M,A	;store character.
E6A8	04              	INR	B	;and count it.
E6A9	C5              RDBUF15	PUSH	B
E6AA	E5              	PUSH	H
E6AB	4F              	MOV	C,A	;echo it now.
E6AC	CD 7F E5        	CALL	SHOWIT
E6AF	E1              	POP	H
E6B0	C1              	POP	B
E6B1	7E              	MOV	A,M	;was it an abort request?
E6B2	FE 03           	CPI	CNTRLC	;control-c abort?
E6B4	78              	MOV	A,B
E6B5	C2 BD E6        	JNZ	RDBUF16
E6B8	FE 01           	CPI	1	;only if at start of line.
E6BA	CA 00 00        	JZ	0
E6BD	B9              RDBUF16	CMP	C	;nope, have we filled the buffer?
E6BE	DA EF E5        	JC	RDBUF1
E6C1	E1              RDBUF17	POP	H	;yes end the line and return.
E6C2	70              	MOV	M,B
E6C3	0E 0D           	MVI	C,CR
E6C5	C3 48 E5        	JMP	OUTCHAR	;output (cr) and return.
	                ;
	                ;   Function to get a character from the console device.
	                ;
E6C8	CD 06 E5        GETCON	CALL	GETECHO	;get and echo.
E6CB	C3 01 E7        	JMP	SETSTAT	;save status and return.
	                ;
	                ;   Function to get a character from the tape reader device.
	                ;
E6CE	CD 15 F2        GETRDR	CALL	READER	;get a character from reader, set status and return.
E6D1	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;  Function to perform direct console i/o. If (C) contains (FF)
	                ; then this is an input request. If (C) contains (FE) then
	                ; this is a status request. Otherwise we are to output (C).
	                ;
E6D4	79              DIRCIO	MOV	A,C	;test for (FF).
E6D5	3C              	INR	A
E6D6	CA E0 E6        	JZ	DIRC1
E6D9	3C              	INR	A	;test for (FE).
E6DA	CA 06 F2        	JZ	CONST
E6DD	C3 0C F2        	JMP	CONOUT	;just output (C).
E6E0	CD 06 F2        DIRC1	CALL	CONST	;this is an input request.
E6E3	B7              	ORA	A
E6E4	CA 91 F1        	JZ	GOBACK1	;not ready? Just return (directly).
E6E7	CD 09 F2        	CALL	CONIN	;yes, get character.
E6EA	C3 01 E7        	JMP	SETSTAT	;set status and return.
	                ;
	                ;   Function to return the i/o byte.
	                ;
E6ED	3A 03 00        GETIOB	LDA	IOBYTE
E6F0	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Function to set the i/o byte.
	                ;
E6F3	21 03 00        SETIOB	LXI	H,IOBYTE
E6F6	71              	MOV	M,C
E6F7	C9              	RET
	                ;
	                ;   Function to print the character string pointed to by (DE)
	                ; on the console device. The string ends with a '$'.
	                ;
E6F8	EB              PRTSTR	XCHG
E6F9	4D              	MOV	C,L
E6FA	44              	MOV	B,H	;now (BC) points to it.
E6FB	C3 D3 E5        	JMP	PRTMESG
	                ;
	                ;   Function to interigate the console device.
	                ;
E6FE	CD 23 E5        GETCSTS	CALL	CKCONSOL
	                ;
	                ;   Get here to set the status and return to the cleanup
	                ; section. Then back to the user.
	                ;
E701	32 45 E7        SETSTAT	STA	STATUS
E704	C9              RTN	RET
	                ;
	                ;   Set the status to 1 (read or write error code).
	                ;
E705	3E 01           IOERR1	MVI	A,1
E707	C3 01 E7        	JMP	SETSTAT
	                ;
E70A	00              OUTFLAG	DB	0	;output flag (non zero means no output).
E70B	02              STARTING:DB	2	;starting position for cursor.
E70C	00              CURPOS	DB	0	;cursor position (0=start of line).
E70D	00              PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
E70E	00              CHARBUF	DB	0	;single input character buffer.
	                ;
	                ;   Stack area for BDOS calls.
	                ;
E70F	00 00           USRSTACK:DW	0	;save users stack pointer here.
	                ;
E711	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
E725	00 00 00 00 

E729	00 00 00 00     	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
E73D	00 00 00 00 

	                STKAREA	EQU	$	;end of stack area.
	                ;
E741	00              USERNO	DB	0	;current user number.
E742	00              ACTIVE	DB	0	;currently active drive.
E743	00 00           PARAMS	DW	0	;save (DE) parameters here on entry.
E745	00 00           STATUS	DW	0	;status returned from bdos function.
	                ;
	                ;   Select error occured, jump to error routine.
	                ;
E747	21 0B E4        SLCTERR	LXI	H,BADSLCT
	                ;
	                ;   Jump to (HL) indirectly.
	                ;
E74A	5E              JUMPHL	MOV	E,M
E74B	23              	INX	H
E74C	56              	MOV	D,M	;now (DE) contain the desired address.
E74D	EB              	XCHG
E74E	E9              	PCHL
	                ;
	                ;   Block move. (DE) to (HL), (C) bytes total.
	                ;
E74F	0C              DE2HL	INR	C	;is count down to zero?
E750	0D              DE2HL1	DCR	C
E751	C8              	RZ		;yes, we are done.
E752	1A              	LDAX	D	;no, move one more byte.
E753	77              	MOV	M,A
E754	13              	INX	D
E755	23              	INX	H
E756	C3 50 E7        	JMP	DE2HL1	;and repeat.
	                ;
	                ;   Select the desired drive.
	                ;
E759	3A 42 E7        SELECT	LDA	ACTIVE	;get active disk.
E75C	4F              	MOV	C,A
E75D	CD 1B F2        	CALL	SELDSK	;select it.
E760	7C              	MOV	A,H	;valid drive?
E761	B5              	ORA	L	;valid drive?
E762	C8              	RZ		;return if not.
	                ;
	                ;   Here, the BIOS returned the address of the parameter block
	                ; in (HL). We will extract the necessary pointers and save them.
	                ;
E763	5E              	MOV	E,M	;yes, get address of translation table into (DE).
E764	23              	INX	H
E765	56              	MOV	D,M
E766	23              	INX	H
E767	22 B3 F1        	SHLD	SCRATCH1	;save pointers to scratch areas.
E76A	23              	INX	H
E76B	23              	INX	H
E76C	22 B5 F1        	SHLD	SCRATCH2	;ditto.
E76F	23              	INX	H
E770	23              	INX	H
E771	22 B7 F1        	SHLD	SCRATCH3	;ditto.
E774	23              	INX	H
E775	23              	INX	H
E776	EB              	XCHG		;now save the translation table address.
E777	22 D0 F1        	SHLD	XLATE
E77A	21 B9 F1        	LXI	H,DIRBUF	;put the next 8 bytes here.
E77D	0E 08           	MVI	C,8	;they consist of the directory buffer
E77F	CD 4F E7        	CALL	DE2HL	;pointer, parameter block pointer,
E782	2A BB F1        	LHLD	DISKPB	;check and allocation vectors.
E785	EB              	XCHG
E786	21 C1 F1        	LXI	H,SECTORS	;move parameter block into our ram.
E789	0E 0F           	MVI	C,15	;it is 15 bytes long.
E78B	CD 4F E7        	CALL	DE2HL
E78E	2A C6 F1        	LHLD	DSKSIZE	;check disk size.
E791	7C              	MOV	A,H	;more than 256 blocks on this?
E792	21 DD F1        	LXI	H,BIGDISK
E795	36 FF           	MVI	M,0FFH	;set to samll.
E797	B7              	ORA	A
E798	CA 9D E7        	JZ	SELECT1
E79B	36 00           	MVI	M,0	;wrong, set to large.
E79D	3E FF           SELECT1	MVI	A,0FFH	;clear the zero flag.
E79F	B7              	ORA	A
E7A0	C9              	RET
	                ;
	                ;   Routine to home the disk track head and clear pointers.
	                ;
E7A1	CD 18 F2        HOMEDRV	CALL	HOME	;home the head.
E7A4	AF              	XRA	A
E7A5	2A B5 F1        	LHLD	SCRATCH2;set our track pointer also.
E7A8	77              	MOV	M,A
E7A9	23              	INX	H
E7AA	77              	MOV	M,A
E7AB	2A B7 F1        	LHLD	SCRATCH3;and our sector pointer.
E7AE	77              	MOV	M,A
E7AF	23              	INX	H
E7B0	77              	MOV	M,A
E7B1	C9              	RET
	                ;
	                ;   Do the actual disk read and check the error return status.
	                ;
E7B2	CD 27 F2        DOREAD	CALL	READ
E7B5	C3 BB E7        	JMP	IORET
	                ;
	                ;   Do the actual disk write and handle any bios error.
	                ;
E7B8	CD 2A F2        DOWRITE	CALL	WRITE
E7BB	B7              IORET	ORA	A
E7BC	C8              	RZ		;return unless an error occured.
E7BD	21 09 E4        	LXI	H,BADSCTR;bad read/write on this sector.
E7C0	C3 4A E7        	JMP	JUMPHL
	                ;
	                ;   Routine to select the track and sector that the desired
	                ; block number falls in.
	                ;
E7C3	2A EA F1        TRKSEC	LHLD	FILEPOS	;get position of last accessed file
E7C6	0E 02           	MVI	C,2	;in directory and compute sector #.
E7C8	CD EA E8        	CALL	SHIFTR	;sector #=file-position/4.
E7CB	22 E5 F1        	SHLD	BLKNMBR	;save this as the block number of interest.
E7CE	22 EC F1        	SHLD	CKSUMTBL;what's it doing here too?
	                ;
	                ;   if the sector number has already been set (BLKNMBR), enter
	                ; at this point.
	                ;
E7D1	21 E5 F1        TRKSEC1	LXI	H,BLKNMBR
E7D4	4E              	MOV	C,M	;move sector number into (BC).
E7D5	23              	INX	H
E7D6	46              	MOV	B,M
E7D7	2A B7 F1        	LHLD	SCRATCH3;get current sector number and
E7DA	5E              	MOV	E,M	;move this into (DE).
E7DB	23              	INX	H
E7DC	56              	MOV	D,M
E7DD	2A B5 F1        	LHLD	SCRATCH2;get current track number.
E7E0	7E              	MOV	A,M	;and this into (HL).
E7E1	23              	INX	H
E7E2	66              	MOV	H,M
E7E3	6F              	MOV	L,A
E7E4	79              TRKSEC2	MOV	A,C	;is desired sector before current one?
E7E5	93              	SUB	E
E7E6	78              	MOV	A,B
E7E7	9A              	SBB	D
E7E8	D2 FA E7        	JNC	TRKSEC3
E7EB	E5              	PUSH	H	;yes, decrement sectors by one track.
E7EC	2A C1 F1        	LHLD	SECTORS	;get sectors per track.
E7EF	7B              	MOV	A,E
E7F0	95              	SUB	L
E7F1	5F              	MOV	E,A
E7F2	7A              	MOV	A,D
E7F3	9C              	SBB	H
E7F4	57              	MOV	D,A	;now we have backed up one full track.
E7F5	E1              	POP	H
E7F6	2B              	DCX	H	;adjust track counter.
E7F7	C3 E4 E7        	JMP	TRKSEC2
E7FA	E5              TRKSEC3	PUSH	H	;desired sector is after current one.
E7FB	2A C1 F1        	LHLD	SECTORS	;get sectors per track.
E7FE	19              	DAD	D	;bump sector pointer to next track.
E7FF	DA 0F E8        	JC	TRKSEC4
E802	79              	MOV	A,C	;is desired sector now before current one?
E803	95              	SUB	L
E804	78              	MOV	A,B
E805	9C              	SBB	H
E806	DA 0F E8        	JC	TRKSEC4
E809	EB              	XCHG		;not yes, increment track counter
E80A	E1              	POP	H	;and continue until it is.
E80B	23              	INX	H
E80C	C3 FA E7        	JMP	TRKSEC3
	                ;
	                ;   here we have determined the track number that contains the
	                ; desired sector.
	                ;
E80F	E1              TRKSEC4	POP	H	;get track number (HL).
E810	C5              	PUSH	B
E811	D5              	PUSH	D
E812	E5              	PUSH	H
E813	EB              	XCHG
E814	2A CE F1        	LHLD	OFFSET	;adjust for first track offset.
E817	19              	DAD	D
E818	44              	MOV	B,H
E819	4D              	MOV	C,L
E81A	CD 1E F2        	CALL	SETTRK	;select this track.
E81D	D1              	POP	D	;reset current track pointer.
E81E	2A B5 F1        	LHLD	SCRATCH2
E821	73              	MOV	M,E
E822	23              	INX	H
E823	72              	MOV	M,D
E824	D1              	POP	D
E825	2A B7 F1        	LHLD	SCRATCH3;reset the first sector on this track.
E828	73              	MOV	M,E
E829	23              	INX	H
E82A	72              	MOV	M,D
E82B	C1              	POP	B
E82C	79              	MOV	A,C	;now subtract the desired one.
E82D	93              	SUB	E	;to make it relative (1-# sectors/track).
E82E	4F              	MOV	C,A
E82F	78              	MOV	A,B
E830	9A              	SBB	D
E831	47              	MOV	B,A
E832	2A D0 F1        	LHLD	XLATE	;translate this sector according to this table.
E835	EB              	XCHG
E836	CD 30 F2        	CALL	SECTRN	;let the bios translate it.
E839	4D              	MOV	C,L
E83A	44              	MOV	B,H
E83B	C3 21 F2        	JMP	SETSEC	;and select it.
	                ;
	                ;   Compute block number from record number (SAVNREC) and
	                ; extent number (SAVEXT).
	                ;
E83E	21 C3 F1        GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
E841	4E              	MOV	C,M	;note that this is base 2 log of ratio.
E842	3A E3 F1        	LDA	SAVNREC	;get record number.
E845	B7              GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
E846	1F              	RAR
E847	0D              	DCR	C
E848	C2 45 E8        	JNZ	GETBLK1
E84B	47              	MOV	B,A	;save result in (B).
E84C	3E 08           	MVI	A,8
E84E	96              	SUB	M
E84F	4F              	MOV	C,A	;compute (C)=8-BLKSHFT.
E850	3A E2 F1        	LDA	SAVEXT
E853	0D              GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
E854	CA 5C E8        	JZ	GETBLK3
E857	B7              	ORA	A
E858	17              	RAL
E859	C3 53 E8        	JMP	GETBLK2
E85C	80              GETBLK3	ADD	B
E85D	C9              	RET
	                ;
	                ;   Routine to extract the (BC) block byte from the fcb pointed
	                ; to by (PARAMS). If this is a big-disk, then these are 16 bit
	                ; block numbers, else they are 8 bit numbers.
	                ; Number is returned in (HL).
	                ;
E85E	2A 43 E7        EXTBLK	LHLD	PARAMS	;get fcb address.
E861	11 10 00        	LXI	D,16	;block numbers start 16 bytes into fcb.
E864	19              	DAD	D
E865	09              	DAD	B
E866	3A DD F1        	LDA	BIGDISK	;are we using a big-disk?
E869	B7              	ORA	A
E86A	CA 71 E8        	JZ	EXTBLK1
E86D	6E              	MOV	L,M	;no, extract an 8 bit number from the fcb.
E86E	26 00           	MVI	H,0
E870	C9              	RET
E871	09              EXTBLK1	DAD	B	;yes, extract a 16 bit number.
E872	5E              	MOV	E,M
E873	23              	INX	H
E874	56              	MOV	D,M
E875	EB              	XCHG		;return in (HL).
E876	C9              	RET
	                ;
	                ;   Compute block number.
	                ;
E877	CD 3E E8        COMBLK	CALL	GETBLOCK
E87A	4F              	MOV	C,A
E87B	06 00           	MVI	B,0
E87D	CD 5E E8        	CALL	EXTBLK
E880	22 E5 F1        	SHLD	BLKNMBR
E883	C9              	RET
	                ;
	                ;   Check for a zero block number (unused).
	                ;
E884	2A E5 F1        CHKBLK	LHLD	BLKNMBR
E887	7D              	MOV	A,L	;is it zero?
E888	B4              	ORA	H
E889	C9              	RET
	                ;
	                ;   Adjust physical block (BLKNMBR) and convert to logical
	                ; sector (LOGSECT). This is the starting sector of this block.
	                ; The actual sector of interest is then added to this and the
	                ; resulting sector number is stored back in (BLKNMBR). This
	                ; will still have to be adjusted for the track number.
	                ;
E88A	3A C3 F1        LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
E88D	2A E5 F1        	LHLD	BLKNMBR	;get physical sector desired.
E890	29              LOGICL1	DAD	H	;compute logical sector number.
E891	3D              	DCR	A	;note logical sectors are 128 bytes long.
E892	C2 90 E8        	JNZ	LOGICL1
E895	22 E7 F1        	SHLD	LOGSECT	;save logical sector.
E898	3A C4 F1        	LDA	BLKMASK	;get block mask.
E89B	4F              	MOV	C,A
E89C	3A E3 F1        	LDA	SAVNREC	;get next sector to access.
E89F	A1              	ANA	C	;extract the relative position within physical block.
E8A0	B5              	ORA	L	;and add it too logical sector.
E8A1	6F              	MOV	L,A
E8A2	22 E5 F1        	SHLD	BLKNMBR	;and store.
E8A5	C9              	RET
	                ;
	                ;   Set (HL) to point to extent byte in fcb.
	                ;
E8A6	2A 43 E7        SETEXT	LHLD	PARAMS
E8A9	11 0C 00        	LXI	D,12	;it is the twelth byte.
E8AC	19              	DAD	D
E8AD	C9              	RET
	                ;
	                ;   Set (HL) to point to record count byte in fcb and (DE) to
	                ; next record number byte.
	                ;
E8AE	2A 43 E7        SETHLDE	LHLD	PARAMS
E8B1	11 0F 00        	LXI	D,15	;record count byte (#15).
E8B4	19              	DAD	D
E8B5	EB              	XCHG
E8B6	21 11 00        	LXI	H,17	;next record number (#32).
E8B9	19              	DAD	D
E8BA	C9              	RET
	                ;
	                ;   Save current file data from fcb.
	                ;
E8BB	CD AE E8        STRDATA	CALL	SETHLDE
E8BE	7E              	MOV	A,M	;get and store record count byte.
E8BF	32 E3 F1        	STA	SAVNREC
E8C2	EB              	XCHG
E8C3	7E              	MOV	A,M	;get and store next record number byte.
E8C4	32 E1 F1        	STA	SAVNXT
E8C7	CD A6 E8        	CALL	SETEXT	;point to extent byte.
E8CA	3A C5 F1        	LDA	EXTMASK	;get extent mask.
E8CD	A6              	ANA	M
E8CE	32 E2 F1        	STA	SAVEXT	;and save extent here.
E8D1	C9              	RET
	                ;
	                ;   Set the next record to access. If (MODE) is set to 2, then
	                ; the last record byte (SAVNREC) has the correct number to access.
	                ; For sequential access, (MODE) will be equal to 1.
	                ;
E8D2	CD AE E8        SETNREC	CALL	SETHLDE
E8D5	3A D5 F1        	LDA	MODE	;get sequential flag (=1).
E8D8	FE 02           	CPI	2	;a 2 indicates that no adder is needed.
E8DA	C2 DE E8        	JNZ	STNREC1
E8DD	AF              	XRA	A	;clear adder (random access?).
E8DE	4F              STNREC1	MOV	C,A
E8DF	3A E3 F1        	LDA	SAVNREC	;get last record number.
E8E2	81              	ADD	C	;increment record count.
E8E3	77              	MOV	M,A	;and set fcb's next record byte.
E8E4	EB              	XCHG
E8E5	3A E1 F1        	LDA	SAVNXT	;get next record byte from storage.
E8E8	77              	MOV	M,A	;and put this into fcb as number of records used.
E8E9	C9              	RET
	                ;
	                ;   Shift (HL) right (C) bits.
	                ;
E8EA	0C              SHIFTR	INR	C
E8EB	0D              SHIFTR1	DCR	C
E8EC	C8              	RZ
E8ED	7C              	MOV	A,H
E8EE	B7              	ORA	A
E8EF	1F              	RAR
E8F0	67              	MOV	H,A
E8F1	7D              	MOV	A,L
E8F2	1F              	RAR
E8F3	6F              	MOV	L,A
E8F4	C3 EB E8        	JMP	SHIFTR1
	                ;
	                ;   Compute the check-sum for the directory buffer. Return
	                ; integer sum in (A).
	                ;
E8F7	0E 80           CHECKSUM:MVI	C,128	;length of buffer.
E8F9	2A B9 F1        	LHLD	DIRBUF	;get its location.
E8FC	AF              	XRA	A	;clear summation byte.
E8FD	86              CHKSUM1	ADD	M	;and compute sum ignoring carries.
E8FE	23              	INX	H
E8FF	0D              	DCR	C
E900	C2 FD E8        	JNZ	CHKSUM1
E903	C9              	RET
	                ;
	                ;   Shift (HL) left (C) bits.
	                ;
E904	0C              SHIFTL	INR	C
E905	0D              SHIFTL1	DCR	C
E906	C8              	RZ
E907	29              	DAD	H	;shift left 1 bit.
E908	C3 05 E9        	JMP	SHIFTL1
	                ;
	                ;   Routine to set a bit in a 16 bit value contained in (BC).
	                ; The bit set depends on the current drive selection.
	                ;
E90B	C5              SETBIT	PUSH	B	;save 16 bit word.
E90C	3A 42 E7        	LDA	ACTIVE	;get active drive.
E90F	4F              	MOV	C,A
E910	21 01 00        	LXI	H,1
E913	CD 04 E9        	CALL	SHIFTL	;shift bit 0 into place.
E916	C1              	POP	B	;now 'or' this with the original word.
E917	79              	MOV	A,C
E918	B5              	ORA	L
E919	6F              	MOV	L,A	;low byte done, do high byte.
E91A	78              	MOV	A,B
E91B	B4              	ORA	H
E91C	67              	MOV	H,A
E91D	C9              	RET
	                ;
	                ;   Extract the write protect status bit for the current drive.
	                ; The result is returned in (A), bit 0.
	                ;
E91E	2A AD F1        GETWPRT	LHLD	WRTPRT	;get status bytes.
E921	3A 42 E7        	LDA	ACTIVE	;which drive is current?
E924	4F              	MOV	C,A
E925	CD EA E8        	CALL	SHIFTR	;shift status such that bit 0 is the
E928	7D              	MOV	A,L	;one of interest for this drive.
E929	E6 01           	ANI	01H	;and isolate it.
E92B	C9              	RET
	                ;
	                ;   Function to write protect the current disk.
	                ;
E92C	21 AD F1        WRTPRTD	LXI	H,WRTPRT;point to status word.
E92F	4E              	MOV	C,M	;set (BC) equal to the status.
E930	23              	INX	H
E931	46              	MOV	B,M
E932	CD 0B E9        	CALL	SETBIT	;and set this bit according to current drive.
E935	22 AD F1        	SHLD	WRTPRT	;then save.
E938	2A C8 F1        	LHLD	DIRSIZE	;now save directory size limit.
E93B	23              	INX	H	;remember the last one.
E93C	EB              	XCHG
E93D	2A B3 F1        	LHLD	SCRATCH1;and store it here.
E940	73              	MOV	M,E	;put low byte.
E941	23              	INX	H
E942	72              	MOV	M,D	;then high byte.
E943	C9              	RET
	                ;
	                ;   Check for a read only file.
	                ;
E944	CD 5E E9        CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
E947	11 09 00        CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
E94A	19              	DAD	D
E94B	7E              	MOV	A,M
E94C	17              	RAL
E94D	D0              	RNC		;return if ok.
E94E	21 0F E4        	LXI	H,ROFILE;else, print error message and terminate.
E951	C3 4A E7        	JMP	JUMPHL
	                ;
	                ;   Check the write protect status of the active disk.
	                ;
E954	CD 1E E9        CHKWPRT	CALL	GETWPRT
E957	C8              	RZ		;return if ok.
E958	21 0D E4        	LXI	H,RODISK;else print message and terminate.
E95B	C3 4A E7        	JMP	JUMPHL
	                ;
	                ;   Routine to set (HL) pointing to the proper entry in the
	                ; directory buffer.
	                ;
E95E	2A B9 F1        FCB2HL	LHLD	DIRBUF	;get address of buffer.
E961	3A E9 F1        	LDA	FCBPOS	;relative position of file.
	                ;
	                ;   Routine to add (A) to (HL).
	                ;
E964	85              ADDA2HL	ADD	L
E965	6F              	MOV	L,A
E966	D0              	RNC
E967	24              	INR	H	;take care of any carry.
E968	C9              	RET
	                ;
	                ;   Routine to get the 's2' byte from the fcb supplied in
	                ; the initial parameter specification.
	                ;
E969	2A 43 E7        GETS2	LHLD	PARAMS	;get address of fcb.
E96C	11 0E 00        	LXI	D,14	;relative position of 's2'.
E96F	19              	DAD	D
E970	7E              	MOV	A,M	;extract this byte.
E971	C9              	RET
	                ;
	                ;   Clear the 's2' byte in the fcb.
	                ;
E972	CD 69 E9        CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
E975	36 00           	MVI	M,0	;now clear it.
E977	C9              	RET
	                ;
	                ;   Set bit 7 in the 's2' byte of the fcb.
	                ;
E978	CD 69 E9        SETS2B7	CALL	GETS2	;get the byte.
E97B	F6 80           	ORI	80H	;and set bit 7.
E97D	77              	MOV	M,A	;then store.
E97E	C9              	RET
	                ;
	                ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
	                ; the difference. This checks to see if there are more file
	                ; names in the directory. We are at (FILEPOS) and there are
	                ; (SCRATCH1) of them to check.
	                ;
E97F	2A EA F1        MOREFLS	LHLD	FILEPOS	;we are here.
E982	EB              	XCHG
E983	2A B3 F1        	LHLD	SCRATCH1;and don't go past here.
E986	7B              	MOV	A,E	;compute difference but don't keep.
E987	96              	SUB	M
E988	23              	INX	H
E989	7A              	MOV	A,D
E98A	9E              	SBB	M	;set carry if no more names.
E98B	C9              	RET
	                ;
	                ;   Call this routine to prevent (SCRATCH1) from being greater
	                ; than (FILEPOS).
	                ;
E98C	CD 7F E9        CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
E98F	D8              	RC
E990	13              	INX	D	;yes, reset it to (FILEPOS).
E991	72              	MOV	M,D
E992	2B              	DCX	H
E993	73              	MOV	M,E
E994	C9              	RET
	                ;
	                ;   Compute (HL)=(DE)-(HL)
	                ;
E995	7B              SUBHL	MOV	A,E	;compute difference.
E996	95              	SUB	L
E997	6F              	MOV	L,A	;store low byte.
E998	7A              	MOV	A,D
E999	9C              	SBB	H
E99A	67              	MOV	H,A	;and then high byte.
E99B	C9              	RET
	                ;
	                ;   Set the directory checksum byte.
	                ;
E99C	0E FF           SETDIR	MVI	C,0FFH
	                ;
	                ;   Routine to set or compare the directory checksum byte. If
	                ; (C)=0ffh, then this will set the checksum byte. Else the byte
	                ; will be checked. If the check fails (the disk has been changed),
	                ; then this disk will be write protected.
	                ;
E99E	2A EC F1        CHECKDIR:LHLD	CKSUMTBL
E9A1	EB              	XCHG
E9A2	2A CC F1        	LHLD	ALLOC1
E9A5	CD 95 E9        	CALL	SUBHL
E9A8	D0              	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
E9A9	C5              	PUSH	B
E9AA	CD F7 E8        	CALL	CHECKSUM;else compute checksum.
E9AD	2A BD F1        	LHLD	CHKVECT	;get address of checksum table.
E9B0	EB              	XCHG
E9B1	2A EC F1        	LHLD	CKSUMTBL
E9B4	19              	DAD	D	;set (HL) to point to byte for this drive.
E9B5	C1              	POP	B
E9B6	0C              	INR	C	;set or check ?
E9B7	CA C4 E9        	JZ	CHKDIR1
E9BA	BE              	CMP	M	;check them.
E9BB	C8              	RZ		;return if they are the same.
E9BC	CD 7F E9        	CALL	MOREFLS	;not the same, do we care?
E9BF	D0              	RNC
E9C0	CD 2C E9        	CALL	WRTPRTD	;yes, mark this as write protected.
E9C3	C9              	RET
E9C4	77              CHKDIR1	MOV	M,A	;just set the byte.
E9C5	C9              	RET
	                ;
	                ;   Do a write to the directory of the current disk.
	                ;
E9C6	CD 9C E9        DIRWRITE:CALL	SETDIR	;set checksum byte.
E9C9	CD E0 E9        	CALL	DIRDMA	;set directory dma address.
E9CC	0E 01           	MVI	C,1	;tell the bios to actually write.
E9CE	CD B8 E7        	CALL	DOWRITE	;then do the write.
E9D1	C3 DA E9        	JMP	DEFDMA
	                ;
	                ;   Read from the directory.
	                ;
E9D4	CD E0 E9        DIRREAD	CALL	DIRDMA	;set the directory dma address.
E9D7	CD B2 E7        	CALL	DOREAD	;and read it.
	                ;
	                ;   Routine to set the dma address to the users choice.
	                ;
E9DA	21 B1 F1        DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
E9DD	C3 E3 E9        	JMP	DIRDMA1
	                ;
	                ;   Routine to set the dma address for directory work.
	                ;
E9E0	21 B9 F1        DIRDMA	LXI	H,DIRBUF
	                ;
	                ;   Set the dma address. On entry, (HL) points to
	                ; word containing the desired dma address.
	                ;
E9E3	4E              DIRDMA1	MOV	C,M
E9E4	23              	INX	H
E9E5	46              	MOV	B,M	;setup (BC) and go to the bios to set it.
E9E6	C3 24 F2        	JMP	SETDMA
	                ;
	                ;   Move the directory buffer into user's dma space.
	                ;
E9E9	2A B9 F1        MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
E9EC	EB              	XCHG
E9ED	2A B1 F1        	LHLD	USERDMA; put it here.
E9F0	0E 80           	MVI	C,128	;this is its length.
E9F2	C3 4F E7        	JMP	DE2HL	;move it now and return.
	                ;
	                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
	                ;
E9F5	21 EA F1        CKFILPOS:LXI	H,FILEPOS
E9F8	7E              	MOV	A,M
E9F9	23              	INX	H
E9FA	BE              	CMP	M	;are both bytes the same?
E9FB	C0              	RNZ
E9FC	3C              	INR	A	;yes, but are they each 0ffh?
E9FD	C9              	RET
	                ;
	                ;   Set location (FILEPOS) to 0ffffh.
	                ;
E9FE	21 FF FF        STFILPOS:LXI	H,0FFFFH
EA01	22 EA F1        	SHLD	FILEPOS
EA04	C9              	RET
	                ;
	                ;   Move on to the next file position within the current
	                ; directory buffer. If no more exist, set pointer to 0ffffh
	                ; and the calling routine will check for this. Enter with (C)
	                ; equal to 0ffh to cause the checksum byte to be set, else we
	                ; will check this disk and set write protect if checksums are
	                ; not the same (applies only if another directory sector must
	                ; be read).
	                ;
EA05	2A C8 F1        NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
EA08	EB              	XCHG
EA09	2A EA F1        	LHLD	FILEPOS	;get current count.
EA0C	23              	INX	H	;go on to the next one.
EA0D	22 EA F1        	SHLD	FILEPOS
EA10	CD 95 E9        	CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
EA13	D2 19 EA        	JNC	NXENT1	;is there more room left?
EA16	C3 FE E9        	JMP	STFILPOS;no. Set this flag and return.
EA19	3A EA F1        NXENT1	LDA	FILEPOS	;get file position within directory.
EA1C	E6 03           	ANI	03H	;only look within this sector (only 4 entries fit).
EA1E	06 05           	MVI	B,5	;convert to relative position (32 bytes each).
EA20	87              NXENT2	ADD	A	;note that this is not efficient code.
EA21	05              	DCR	B	;5 'ADD A's would be better.
EA22	C2 20 EA        	JNZ	NXENT2
EA25	32 E9 F1        	STA	FCBPOS	;save it as position of fcb.
EA28	B7              	ORA	A
EA29	C0              	RNZ		;return if we are within buffer.
EA2A	C5              	PUSH	B
EA2B	CD C3 E7        	CALL	TRKSEC	;we need the next directory sector.
EA2E	CD D4 E9        	CALL	DIRREAD
EA31	C1              	POP	B
EA32	C3 9E E9        	JMP	CHECKDIR
	                ;
	                ;   Routine to to get a bit from the disk space allocation
	                ; map. It is returned in (A), bit position 0. On entry to here,
	                ; set (BC) to the block number on the disk to check.
	                ; On return, (D) will contain the original bit position for
	                ; this block number and (HL) will point to the address for it.
	                ;
EA35	79              CKBITMAP:MOV	A,C	;determine bit number of interest.
EA36	E6 07           	ANI	07H	;compute (D)=(E)=(C and 7)+1.
EA38	3C              	INR	A
EA39	5F              	MOV	E,A	;save particular bit number.
EA3A	57              	MOV	D,A
	                ;
	                ;   compute (BC)=(BC)/8.
	                ;
EA3B	79              	MOV	A,C
EA3C	0F              	RRC		;now shift right 3 bits.
EA3D	0F              	RRC
EA3E	0F              	RRC
EA3F	E6 1F           	ANI	1FH	;and clear bits 7,6,5.
EA41	4F              	MOV	C,A
EA42	78              	MOV	A,B
EA43	87              	ADD	A	;now shift (B) into bits 7,6,5.
EA44	87              	ADD	A
EA45	87              	ADD	A
EA46	87              	ADD	A
EA47	87              	ADD	A
EA48	B1              	ORA	C	;and add in (C).
EA49	4F              	MOV	C,A	;ok, (C) ha been completed.
EA4A	78              	MOV	A,B	;is there a better way of doing this?
EA4B	0F              	RRC
EA4C	0F              	RRC
EA4D	0F              	RRC
EA4E	E6 1F           	ANI	1FH
EA50	47              	MOV	B,A	;and now (B) is completed.
	                ;
	                ;   use this as an offset into the disk space allocation
	                ; table.
	                ;
EA51	2A BF F1        	LHLD	ALOCVECT
EA54	09              	DAD	B
EA55	7E              	MOV	A,M	;now get correct byte.
EA56	07              CKBMAP1	RLC		;get correct bit into position 0.
EA57	1D              	DCR	E
EA58	C2 56 EA        	JNZ	CKBMAP1
EA5B	C9              	RET
	                ;
	                ;   Set or clear the bit map such that block number (BC) will be marked
	                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
	                ; 1 then it will be set (don't use anyother values).
	                ;
EA5C	D5              STBITMAP:PUSH	D
EA5D	CD 35 EA        	CALL	CKBITMAP;get the byte of interest.
EA60	E6 FE           	ANI	0FEH	;clear the affected bit.
EA62	C1              	POP	B
EA63	B1              	ORA	C	;and now set it acording to (C).
	                ;
	                ;  entry to restore the original bit position and then store
	                ; in table. (A) contains the value, (D) contains the bit
	                ; position (1-8), and (HL) points to the address within the
	                ; space allocation table for this byte.
	                ;
EA64	0F              STBMAP1	RRC		;restore original bit position.
EA65	15              	DCR	D
EA66	C2 64 EA        	JNZ	STBMAP1
EA69	77              	MOV	M,A	;and stor byte in table.
EA6A	C9              	RET
	                ;
	                ;   Set/clear space used bits in allocation map for this file.
	                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
	                ;
EA6B	CD 5E E9        SETFILE	CALL	FCB2HL	;get address of fcb
EA6E	11 10 00        	LXI	D,16
EA71	19              	DAD	D	;get to block number bytes.
EA72	C5              	PUSH	B
EA73	0E 11           	MVI	C,17	;check all 17 bytes (max) of table.
EA75	D1              SETFL1	POP	D
EA76	0D              	DCR	C	;done all bytes yet?
EA77	C8              	RZ
EA78	D5              	PUSH	D
EA79	3A DD F1        	LDA	BIGDISK	;check disk size for 16 bit block numbers.
EA7C	B7              	ORA	A
EA7D	CA 88 EA        	JZ	SETFL2
EA80	C5              	PUSH	B	;only 8 bit numbers. set (BC) to this one.
EA81	E5              	PUSH	H
EA82	4E              	MOV	C,M	;get low byte from table, always
EA83	06 00           	MVI	B,0	;set high byte to zero.
EA85	C3 8E EA        	JMP	SETFL3
EA88	0D              SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
EA89	C5              	PUSH	B
EA8A	4E              	MOV	C,M	;now get both the low and high bytes.
EA8B	23              	INX	H
EA8C	46              	MOV	B,M
EA8D	E5              	PUSH	H
EA8E	79              SETFL3	MOV	A,C	;block used?
EA8F	B0              	ORA	B
EA90	CA 9D EA        	JZ	SETFL4
EA93	2A C6 F1        	LHLD	DSKSIZE	;is this block number within the
EA96	7D              	MOV	A,L	;space on the disk?
EA97	91              	SUB	C
EA98	7C              	MOV	A,H
EA99	98              	SBB	B
EA9A	D4 5C EA        	CNC	STBITMAP;yes, set the proper bit.
EA9D	E1              SETFL4	POP	H	;point to next block number in fcb.
EA9E	23              	INX	H
EA9F	C1              	POP	B
EAA0	C3 75 EA        	JMP	SETFL1
	                ;
	                ;   Construct the space used allocation bit map for the active
	                ; drive. If a file name starts with '$' and it is under the
	                ; current user number, then (STATUS) is set to minus 1. Otherwise
	                ; it is not set at all.
	                ;
EAA3	2A C6 F1        BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
EAA6	0E 03           	MVI	C,3
EAA8	CD EA E8        	CALL	SHIFTR	;(HL)=(HL)/8.
EAAB	23              	INX	H	;at lease 1 byte.
EAAC	44              	MOV	B,H
EAAD	4D              	MOV	C,L	;set (BC) to the allocation table length.
	                ;
	                ;   Initialize the bitmap for this drive. Right now, the first
	                ; two bytes are specified by the disk parameter block. However
	                ; a patch could be entered here if it were necessary to setup
	                ; this table in a special mannor. For example, the bios could
	                ; determine locations of 'bad blocks' and set them as already
	                ; 'used' in the map.
	                ;
EAAE	2A BF F1        	LHLD	ALOCVECT;now zero out the table now.
EAB1	36 00           BITMAP1	MVI	M,0
EAB3	23              	INX	H
EAB4	0B              	DCX	B
EAB5	78              	MOV	A,B
EAB6	B1              	ORA	C
EAB7	C2 B1 EA        	JNZ	BITMAP1
EABA	2A CA F1        	LHLD	ALLOC0	;get initial space used by directory.
EABD	EB              	XCHG
EABE	2A BF F1        	LHLD	ALOCVECT;and put this into map.
EAC1	73              	MOV	M,E
EAC2	23              	INX	H
EAC3	72              	MOV	M,D
	                ;
	                ;   End of initialization portion.
	                ;
EAC4	CD A1 E7        	CALL	HOMEDRV	;now home the drive.
EAC7	2A B3 F1        	LHLD	SCRATCH1
EACA	36 03           	MVI	M,3	;force next directory request to read
EACC	23              	INX	H	;in a sector.
EACD	36 00           	MVI	M,0
EACF	CD FE E9        	CALL	STFILPOS;clear initial file position also.
EAD2	0E FF           BITMAP2	MVI	C,0FFH	;read next file name in directory
EAD4	CD 05 EA        	CALL	NXENTRY	;and set checksum byte.
EAD7	CD F5 E9        	CALL	CKFILPOS;is there another file?
EADA	C8              	RZ
EADB	CD 5E E9        	CALL	FCB2HL	;yes, get its address.
EADE	3E E5           	MVI	A,0E5H
EAE0	BE              	CMP	M	;empty file entry?
EAE1	CA D2 EA        	JZ	BITMAP2
EAE4	3A 41 E7        	LDA	USERNO	;no, correct user number?
EAE7	BE              	CMP	M
EAE8	C2 F6 EA        	JNZ	BITMAP3
EAEB	23              	INX	H
EAEC	7E              	MOV	A,M	;yes, does name start with a '$'?
EAED	D6 24           	SUI	'$'
EAEF	C2 F6 EA        	JNZ	BITMAP3
EAF2	3D              	DCR	A	;yes, set atatus to minus one.
EAF3	32 45 E7        	STA	STATUS
EAF6	0E 01           BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
EAF8	CD 6B EA        	CALL	SETFILE
EAFB	CD 8C E9        	CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
EAFE	C3 D2 EA        	JMP	BITMAP2
	                ;
	                ;   Set the status (STATUS) and return.
	                ;
EB01	3A D4 F1        STSTATUS:LDA	FNDSTAT
EB04	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Check extents in (A) and (C). Set the zero flag if they
	                ; are the same. The number of 16k chunks of disk space that
	                ; the directory extent covers is expressad is (EXTMASK+1).
	                ; No registers are modified.
	                ;
EB07	C5              SAMEXT	PUSH	B
EB08	F5              	PUSH	PSW
EB09	3A C5 F1        	LDA	EXTMASK	;get extent mask and use it to
EB0C	2F              	CMA		;to compare both extent numbers.
EB0D	47              	MOV	B,A	;save resulting mask here.
EB0E	79              	MOV	A,C	;mask first extent and save in (C).
EB0F	A0              	ANA	B
EB10	4F              	MOV	C,A
EB11	F1              	POP	PSW	;now mask second extent and compare
EB12	A0              	ANA	B	;with the first one.
EB13	91              	SUB	C
EB14	E6 1F           	ANI	1FH	;(* only check buts 0-4 *)
EB16	C1              	POP	B	;the zero flag is set if they are the same.
EB17	C9              	RET		;restore (BC) and return.
	                ;
	                ;   Search for the first occurence of a file name. On entry,
	                ; register (C) should contain the number of bytes of the fcb
	                ; that must match.
	                ;
EB18	3E FF           FINDFST	MVI	A,0FFH
EB1A	32 D4 F1        	STA	FNDSTAT
EB1D	21 D8 F1        	LXI	H,COUNTER;save character count.
EB20	71              	MOV	M,C
EB21	2A 43 E7        	LHLD	PARAMS	;get filename to match.
EB24	22 D9 F1        	SHLD	SAVEFCB	;and save.
EB27	CD FE E9        	CALL	STFILPOS;clear initial file position (set to 0ffffh).
EB2A	CD A1 E7        	CALL	HOMEDRV	;home the drive.
	                ;
	                ;   Entry to locate the next occurence of a filename within the
	                ; directory. The disk is not expected to have been changed. If
	                ; it was, then it will be write protected.
	                ;
EB2D	0E 00           FINDNXT	MVI	C,0	;write protect the disk if changed.
EB2F	CD 05 EA        	CALL	NXENTRY	;get next filename entry in directory.
EB32	CD F5 E9        	CALL	CKFILPOS;is file position = 0ffffh?
EB35	CA 94 EB        	JZ	FNDNXT6	;yes, exit now then.
EB38	2A D9 F1        	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
EB3B	EB              	XCHG
EB3C	1A              	LDAX	D
EB3D	FE E5           	CPI	0E5H	;empty directory entry?
EB3F	CA 4A EB        	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
EB42	D5              	PUSH	D
EB43	CD 7F E9        	CALL	MOREFLS	;more files in directory?
EB46	D1              	POP	D
EB47	D2 94 EB        	JNC	FNDNXT6	;no more. Exit now.
EB4A	CD 5E E9        FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
EB4D	3A D8 F1        	LDA	COUNTER	;get number of bytes (characters) to check.
EB50	4F              	MOV	C,A
EB51	06 00           	MVI	B,0	;initialize byte position counter.
EB53	79              FNDNXT2	MOV	A,C	;are we done with the compare?
EB54	B7              	ORA	A
EB55	CA 83 EB        	JZ	FNDNXT5
EB58	1A              	LDAX	D	;no, check next byte.
EB59	FE 3F           	CPI	'?'	;don't care about this character?
EB5B	CA 7C EB        	JZ	FNDNXT4
EB5E	78              	MOV	A,B	;get bytes position in fcb.
EB5F	FE 0D           	CPI	13	;don't care about the thirteenth byte either.
EB61	CA 7C EB        	JZ	FNDNXT4
EB64	FE 0C           	CPI	12	;extent byte?
EB66	1A              	LDAX	D
EB67	CA 73 EB        	JZ	FNDNXT3
EB6A	96              	SUB	M	;otherwise compare characters.
EB6B	E6 7F           	ANI	7FH
EB6D	C2 2D EB        	JNZ	FINDNXT	;not the same, check next entry.
EB70	C3 7C EB        	JMP	FNDNXT4	;so far so good, keep checking.
EB73	C5              FNDNXT3	PUSH	B	;check the extent byte here.
EB74	4E              	MOV	C,M
EB75	CD 07 EB        	CALL	SAMEXT
EB78	C1              	POP	B
EB79	C2 2D EB        	JNZ	FINDNXT	;not the same, look some more.
	                ;
	                ;   So far the names compare. Bump pointers to the next byte
	                ; and continue until all (C) characters have been checked.
	                ;
EB7C	13              FNDNXT4	INX	D	;bump pointers.
EB7D	23              	INX	H
EB7E	04              	INR	B
EB7F	0D              	DCR	C	;adjust character counter.
EB80	C3 53 EB        	JMP	FNDNXT2
EB83	3A EA F1        FNDNXT5	LDA	FILEPOS	;return the position of this entry.
EB86	E6 03           	ANI	03H
EB88	32 45 E7        	STA	STATUS
EB8B	21 D4 F1        	LXI	H,FNDSTAT
EB8E	7E              	MOV	A,M
EB8F	17              	RAL
EB90	D0              	RNC
EB91	AF              	XRA	A
EB92	77              	MOV	M,A
EB93	C9              	RET
	                ;
	                ;   Filename was not found. Set appropriate status.
	                ;
EB94	CD FE E9        FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
EB97	3E FF           	MVI	A,0FFH	;say not located.
EB99	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Erase files from the directory. Only the first byte of the
	                ; fcb will be affected. It is set to (E5).
	                ;
EB9C	CD 54 E9        ERAFILE	CALL	CHKWPRT	;is disk write protected?
EB9F	0E 0C           	MVI	C,12	;only compare file names.
EBA1	CD 18 EB        	CALL	FINDFST	;get first file name.
EBA4	CD F5 E9        ERAFIL1	CALL	CKFILPOS;any found?
EBA7	C8              	RZ		;nope, we must be done.
EBA8	CD 44 E9        	CALL	CHKROFL	;is file read only?
EBAB	CD 5E E9        	CALL	FCB2HL	;nope, get address of fcb and
EBAE	36 E5           	MVI	M,0E5H	;set first byte to 'empty'.
EBB0	0E 00           	MVI	C,0	;clear the space from the bit map.
EBB2	CD 6B EA        	CALL	SETFILE
EBB5	CD C6 E9        	CALL	DIRWRITE;now write the directory sector back out.
EBB8	CD 2D EB        	CALL	FINDNXT	;find the next file name.
EBBB	C3 A4 EB        	JMP	ERAFIL1	;and repeat process.
	                ;
	                ;   Look through the space allocation map (bit map) for the
	                ; next available block. Start searching at block number (BC-1).
	                ; The search procedure is to look for an empty block that is
	                ; before the starting block. If not empty, look at a later
	                ; block number. In this way, we return the closest empty block
	                ; on either side of the 'target' block number. This will speed
	                ; access on random devices. For serial devices, this should be
	                ; changed to look in the forward direction first and then start
	                ; at the front and search some more.
	                ;
	                ;   On return, (DE)= block number that is empty and (HL) =0
	                ; if no empry block was found.
	                ;
EBBE	50              FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
EBBF	59              	MOV	E,C
	                ;
	                ;   Look before target block. Registers (BC) are used as the lower
	                ; pointer and (DE) as the upper pointer.
	                ;
EBC0	79              FNDSPA1	MOV	A,C	;is block 0 specified?
EBC1	B0              	ORA	B
EBC2	CA D1 EB        	JZ	FNDSPA2
EBC5	0B              	DCX	B	;nope, check previous block.
EBC6	D5              	PUSH	D
EBC7	C5              	PUSH	B
EBC8	CD 35 EA        	CALL	CKBITMAP
EBCB	1F              	RAR		;is this block empty?
EBCC	D2 EC EB        	JNC	FNDSPA3	;yes. use this.
	                ;
	                ;   Note that the above logic gets the first block that it finds
	                ; that is empty. Thus a file could be written 'backward' making
	                ; it very slow to access. This could be changed to look for the
	                ; first empty block and then continue until the start of this
	                ; empty space is located and then used that starting block.
	                ; This should help speed up access to some files especially on
	                ; a well used disk with lots of fairly small 'holes'.
	                ;
EBCF	C1              	POP	B	;nope, check some more.
EBD0	D1              	POP	D
	                ;
	                ;   Now look after target block.
	                ;
EBD1	2A C6 F1        FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
EBD4	7B              	MOV	A,E
EBD5	95              	SUB	L
EBD6	7A              	MOV	A,D
EBD7	9C              	SBB	H
EBD8	D2 F4 EB        	JNC	FNDSPA4
EBDB	13              	INX	D	;yes, move on to next one.
EBDC	C5              	PUSH	B
EBDD	D5              	PUSH	D
EBDE	42              	MOV	B,D
EBDF	4B              	MOV	C,E
EBE0	CD 35 EA        	CALL	CKBITMAP;check it.
EBE3	1F              	RAR		;empty?
EBE4	D2 EC EB        	JNC	FNDSPA3
EBE7	D1              	POP	D	;nope, continue searching.
EBE8	C1              	POP	B
EBE9	C3 C0 EB        	JMP	FNDSPA1
	                ;
	                ;   Empty block found. Set it as used and return with (HL)
	                ; pointing to it (true?).
	                ;
EBEC	17              FNDSPA3	RAL		;reset byte.
EBED	3C              	INR	A	;and set bit 0.
EBEE	CD 64 EA        	CALL	STBMAP1	;update bit map.
EBF1	E1              	POP	H	;set return registers.
EBF2	D1              	POP	D
EBF3	C9              	RET
	                ;
	                ;   Free block was not found. If (BC) is not zero, then we have
	                ; not checked all of the disk space.
	                ;
EBF4	79              FNDSPA4	MOV	A,C
EBF5	B0              	ORA	B
EBF6	C2 C0 EB        	JNZ	FNDSPA1
EBF9	21 00 00        	LXI	H,0	;set 'not found' status.
EBFC	C9              	RET
	                ;
	                ;   Move a complete fcb entry into the directory and write it.
	                ;
EBFD	0E 00           FCBSET	MVI	C,0
EBFF	1E 20           	MVI	E,32	;length of each entry.
	                ;
	                ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
	                ; fcb in directory starting at relative byte (C). This updated
	                ; directory buffer is then written to the disk.
	                ;
EC01	D5              UPDATE	PUSH	D
EC02	06 00           	MVI	B,0	;set (BC) to relative byte position.
EC04	2A 43 E7        	LHLD	PARAMS	;get address of fcb.
EC07	09              	DAD	B	;compute starting byte.
EC08	EB              	XCHG
EC09	CD 5E E9        	CALL	FCB2HL	;get address of fcb to update in directory.
EC0C	C1              	POP	B	;set (C) to number of bytes to change.
EC0D	CD 4F E7        	CALL	DE2HL
EC10	CD C3 E7        UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
EC13	C3 C6 E9        	JMP	DIRWRITE	;then write this sector out.
	                ;
	                ;   Routine to change the name of all files on the disk with a
	                ; specified name. The fcb contains the current name as the
	                ; first 12 characters and the new name 16 bytes into the fcb.
	                ;
EC16	CD 54 E9        CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
EC19	0E 0C           	MVI	C,12	;match first 12 bytes of fcb only.
EC1B	CD 18 EB        	CALL	FINDFST	;get first name.
EC1E	2A 43 E7        	LHLD	PARAMS	;get address of fcb.
EC21	7E              	MOV	A,M	;get user number.
EC22	11 10 00        	LXI	D,16	;move over to desired name.
EC25	19              	DAD	D
EC26	77              	MOV	M,A	;keep same user number.
EC27	CD F5 E9        CHGNAM1	CALL	CKFILPOS;any matching file found?
EC2A	C8              	RZ		;no, we must be done.
EC2B	CD 44 E9        	CALL	CHKROFL	;check for read only file.
EC2E	0E 10           	MVI	C,16	;start 16 bytes into fcb.
EC30	1E 0C           	MVI	E,12	;and update the first 12 bytes of directory.
EC32	CD 01 EC        	CALL	UPDATE
EC35	CD 2D EB        	CALL	FINDNXT	;get te next file name.
EC38	C3 27 EC        	JMP	CHGNAM1	;and continue.
	                ;
	                ;   Update a files attributes. The procedure is to search for
	                ; every file with the same name as shown in fcb (ignoring bit 7)
	                ; and then to update it (which includes bit 7). No other changes
	                ; are made.
	                ;
EC3B	0E 0C           SAVEATTR:MVI	C,12	;match first 12 bytes.
EC3D	CD 18 EB        	CALL	FINDFST	;look for first filename.
EC40	CD F5 E9        SAVATR1	CALL	CKFILPOS;was one found?
EC43	C8              	RZ		;nope, we must be done.
EC44	0E 00           	MVI	C,0	;yes, update the first 12 bytes now.
EC46	1E 0C           	MVI	E,12
EC48	CD 01 EC        	CALL	UPDATE	;update filename and write directory.
EC4B	CD 2D EB        	CALL	FINDNXT	;and get the next file.
EC4E	C3 40 EC        	JMP	SAVATR1	;then continue until done.
	                ;
	                ;  Open a file (name specified in fcb).
	                ;
EC51	0E 0F           OPENIT	MVI	C,15	;compare the first 15 bytes.
EC53	CD 18 EB        	CALL	FINDFST	;get the first one in directory.
EC56	CD F5 E9        	CALL	CKFILPOS;any at all?
EC59	C8              	RZ
EC5A	CD A6 E8        OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
EC5D	7E              	MOV	A,M	;and get it.
EC5E	F5              	PUSH	PSW	;save it and address.
EC5F	E5              	PUSH	H
EC60	CD 5E E9        	CALL	FCB2HL	;point to fcb in directory.
EC63	EB              	XCHG
EC64	2A 43 E7        	LHLD	PARAMS	;this is the users copy.
EC67	0E 20           	MVI	C,32	;move it into users space.
EC69	D5              	PUSH	D
EC6A	CD 4F E7        	CALL	DE2HL
EC6D	CD 78 E9        	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
EC70	D1              	POP	D	;now get the extent byte from this fcb.
EC71	21 0C 00        	LXI	H,12
EC74	19              	DAD	D
EC75	4E              	MOV	C,M	;into (C).
EC76	21 0F 00        	LXI	H,15	;now get the record count byte into (B).
EC79	19              	DAD	D
EC7A	46              	MOV	B,M
EC7B	E1              	POP	H	;keep the same extent as the user had originally.
EC7C	F1              	POP	PSW
EC7D	77              	MOV	M,A
EC7E	79              	MOV	A,C	;is it the same as in the directory fcb?
EC7F	BE              	CMP	M
EC80	78              	MOV	A,B	;if yes, then use the same record count.
EC81	CA 8B EC        	JZ	OPENIT2
EC84	3E 00           	MVI	A,0	;if the user specified an extent greater than
EC86	DA 8B EC        	JC	OPENIT2	;the one in the directory, then set record count to 0.
EC89	3E 80           	MVI	A,128	;otherwise set to maximum.
EC8B	2A 43 E7        OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
EC8E	11 0F 00        	LXI	D,15
EC91	19              	DAD	D	;compute relative position.
EC92	77              	MOV	M,A	;and set the record count.
EC93	C9              	RET
	                ;
	                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
	                ; point to a zero value (16 bit).
	                ;   Return with zero flag set it (DE) was moved. Registers (DE)
	                ; and (HL) are not changed. However (A) is.
	                ;
EC94	7E              MOVEWORD:MOV	A,M	;check for a zero word.
EC95	23              	INX	H
EC96	B6              	ORA	M	;both bytes zero?
EC97	2B              	DCX	H
EC98	C0              	RNZ		;nope, just return.
EC99	1A              	LDAX	D	;yes, move two bytes from (DE) into
EC9A	77              	MOV	M,A	;this zero space.
EC9B	13              	INX	D
EC9C	23              	INX	H
EC9D	1A              	LDAX	D
EC9E	77              	MOV	M,A
EC9F	1B              	DCX	D	;don't disturb these registers.
ECA0	2B              	DCX	H
ECA1	C9              	RET
	                ;
	                ;   Get here to close a file specified by (fcb).
	                ;
ECA2	AF              CLOSEIT	XRA	A	;clear status and file position bytes.
ECA3	32 45 E7        	STA	STATUS
ECA6	32 EA F1        	STA	FILEPOS
ECA9	32 EB F1        	STA	FILEPOS+1
ECAC	CD 1E E9        	CALL	GETWPRT	;get write protect bit for this drive.
ECAF	C0              	RNZ		;just return if it is set.
ECB0	CD 69 E9        	CALL	GETS2	;else get the 's2' byte.
ECB3	E6 80           	ANI	80H	;and look at bit 7 (file unmodified?).
ECB5	C0              	RNZ		;just return if set.
ECB6	0E 0F           	MVI	C,15	;else look up this file in directory.
ECB8	CD 18 EB        	CALL	FINDFST
ECBB	CD F5 E9        	CALL	CKFILPOS;was it found?
ECBE	C8              	RZ		;just return if not.
ECBF	01 10 00        	LXI	B,16	;set (HL) pointing to records used section.
ECC2	CD 5E E9        	CALL	FCB2HL
ECC5	09              	DAD	B
ECC6	EB              	XCHG
ECC7	2A 43 E7        	LHLD	PARAMS	;do the same for users specified fcb.
ECCA	09              	DAD	B
ECCB	0E 10           	MVI	C,16	;this many bytes are present in this extent.
ECCD	3A DD F1        CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
ECD0	B7              	ORA	A
ECD1	CA E8 EC        	JZ	CLOSEIT4
ECD4	7E              	MOV	A,M	;just 8 bit. Get one from users fcb.
ECD5	B7              	ORA	A
ECD6	1A              	LDAX	D	;now get one from directory fcb.
ECD7	C2 DB EC        	JNZ	CLOSEIT2
ECDA	77              	MOV	M,A	;users byte was zero. Update from directory.
ECDB	B7              CLOSEIT2:ORA	A
ECDC	C2 E1 EC        	JNZ	CLOSEIT3
ECDF	7E              	MOV	A,M	;directories byte was zero, update from users fcb.
ECE0	12              	STAX	D
ECE1	BE              CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
ECE2	C2 1F ED        	JNZ	CLOSEIT7	;then close error if they are not the same.
ECE5	C3 FD EC        	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
ECE8	CD 94 EC        CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
ECEB	EB              	XCHG
ECEC	CD 94 EC        	CALL	MOVEWORD;update directories fcb if it is zero.
ECEF	EB              	XCHG
ECF0	1A              	LDAX	D	;if these two values are no different,
ECF1	BE              	CMP	M	;then a close error occured.
ECF2	C2 1F ED        	JNZ	CLOSEIT7
ECF5	13              	INX	D	;check second byte.
ECF6	23              	INX	H
ECF7	1A              	LDAX	D
ECF8	BE              	CMP	M
ECF9	C2 1F ED        	JNZ	CLOSEIT7
ECFC	0D              	DCR	C	;remember 16 bit values.
ECFD	13              CLOSEIT5:INX	D	;bump to next item in table.
ECFE	23              	INX	H
ECFF	0D              	DCR	C	;there are 16 entries only.
ED00	C2 CD EC        	JNZ	CLOSEIT1;continue if more to do.
ED03	01 EC FF        	LXI	B,0FFECH;backup 20 places (extent byte).
ED06	09              	DAD	B
ED07	EB              	XCHG
ED08	09              	DAD	B
ED09	1A              	LDAX	D
ED0A	BE              	CMP	M	;directory's extent already greater than the
ED0B	DA 17 ED        	JC	CLOSEIT6	;users extent?
ED0E	77              	MOV	M,A	;no, update directory extent.
ED0F	01 03 00        	LXI	B,3	;and update the record count byte in
ED12	09              	DAD	B	;directories fcb.
ED13	EB              	XCHG
ED14	09              	DAD	B
ED15	7E              	MOV	A,M	;get from user.
ED16	12              	STAX	D	;and put in directory.
ED17	3E FF           CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
ED19	32 D2 F1        	STA	CLOSEFLG
ED1C	C3 10 EC        	JMP	UPDATE1	;update the directory now.
ED1F	21 45 E7        CLOSEIT7:LXI	H,STATUS;set return status and then return.
ED22	35              	DCR	M
ED23	C9              	RET
	                ;
	                ;   Routine to get the next empty space in the directory. It
	                ; will then be cleared for use.
	                ;
ED24	CD 54 E9        GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
ED27	2A 43 E7        	LHLD	PARAMS	;save current parameters (fcb).
ED2A	E5              	PUSH	H
ED2B	21 AC F1        	LXI	H,EMPTYFCB;use special one for empty space.
ED2E	22 43 E7        	SHLD	PARAMS
ED31	0E 01           	MVI	C,1	;search for first empty spot in directory.
ED33	CD 18 EB        	CALL	FINDFST	;(* only check first byte *)
ED36	CD F5 E9        	CALL	CKFILPOS;none?
ED39	E1              	POP	H
ED3A	22 43 E7        	SHLD	PARAMS	;restore original fcb address.
ED3D	C8              	RZ		;return if no more space.
ED3E	EB              	XCHG
ED3F	21 0F 00        	LXI	H,15	;point to number of records for this file.
ED42	19              	DAD	D
ED43	0E 11           	MVI	C,17	;and clear all of this space.
ED45	AF              	XRA	A
ED46	77              GETMT1	MOV	M,A
ED47	23              	INX	H
ED48	0D              	DCR	C
ED49	C2 46 ED        	JNZ	GETMT1
ED4C	21 0D 00        	LXI	H,13	;clear the 's1' byte also.
ED4F	19              	DAD	D
ED50	77              	MOV	M,A
ED51	CD 8C E9        	CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
ED54	CD FD EB        	CALL	FCBSET	;write out this fcb entry to directory.
ED57	C3 78 E9        	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
	                ;
	                ;   Routine to close the current extent and open the next one
	                ; for reading.
	                ;
ED5A	AF              GETNEXT	XRA	A
ED5B	32 D2 F1        	STA	CLOSEFLG;clear close flag.
ED5E	CD A2 EC        	CALL	CLOSEIT	;close this extent.
ED61	CD F5 E9        	CALL	CKFILPOS
ED64	C8              	RZ		;not there???
ED65	2A 43 E7        	LHLD	PARAMS	;get extent byte.
ED68	01 0C 00        	LXI	B,12
ED6B	09              	DAD	B
ED6C	7E              	MOV	A,M	;and increment it.
ED6D	3C              	INR	A
ED6E	E6 1F           	ANI	1FH	;keep within range 0-31.
ED70	77              	MOV	M,A
ED71	CA 83 ED        	JZ	GTNEXT1	;overflow?
ED74	47              	MOV	B,A	;mask extent byte.
ED75	3A C5 F1        	LDA	EXTMASK
ED78	A0              	ANA	B
ED79	21 D2 F1        	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
ED7C	A6              	ANA	M
ED7D	CA 8E ED        	JZ	GTNEXT2	;if zero, we must read in next extent.
ED80	C3 AC ED        	JMP	GTNEXT3	;else, it is already in memory.
ED83	01 02 00        GTNEXT1	LXI	B,2	;Point to the 's2' byte.
ED86	09              	DAD	B
ED87	34              	INR	M	;and bump it.
ED88	7E              	MOV	A,M	;too many extents?
ED89	E6 0F           	ANI	0FH
ED8B	CA B6 ED        	JZ	GTNEXT5	;yes, set error code.
	                ;
	                ;   Get here to open the next extent.
	                ;
ED8E	0E 0F           GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
ED90	CD 18 EB        	CALL	FINDFST	;find the first one.
ED93	CD F5 E9        	CALL	CKFILPOS;none available?
ED96	C2 AC ED        	JNZ	GTNEXT3
ED99	3A D3 F1        	LDA	RDWRTFLG;no extent present. Can we open an empty one?
ED9C	3C              	INR	A	;0ffh means reading (so not possible).
ED9D	CA B6 ED        	JZ	GTNEXT5	;or an error.
EDA0	CD 24 ED        	CALL	GETEMPTY;we are writing, get an empty entry.
EDA3	CD F5 E9        	CALL	CKFILPOS;none?
EDA6	CA B6 ED        	JZ	GTNEXT5	;error if true.
EDA9	C3 AF ED        	JMP	GTNEXT4	;else we are almost done.
EDAC	CD 5A EC        GTNEXT3	CALL	OPENIT1	;open this extent.
EDAF	CD BB E8        GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
EDB2	AF              	XRA	A	;clear status and return.
EDB3	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Error in extending the file. Too many extents were needed
	                ; or not enough space on the disk.
	                ;
EDB6	CD 05 E7        GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
EDB9	C3 78 E9        	JMP	SETS2B7	;so this is not written on a close.
	                ;
	                ;   Read a sequential file.
	                ;
EDBC	3E 01           RDSEQ	MVI	A,1	;set sequential access mode.
EDBE	32 D5 F1        	STA	MODE
EDC1	3E FF           RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
EDC3	32 D3 F1        	STA	RDWRTFLG
EDC6	CD BB E8        	CALL	STRDATA	;put rec# and ext# into fcb.
EDC9	3A E3 F1        	LDA	SAVNREC	;get next record to read.
EDCC	21 E1 F1        	LXI	H,SAVNXT;get number of records in extent.
EDCF	BE              	CMP	M	;within this extent?
EDD0	DA E6 ED        	JC	RDSEQ2
EDD3	FE 80           	CPI	128	;no. Is this extent fully used?
EDD5	C2 FB ED        	JNZ	RDSEQ3	;no. End-of-file.
EDD8	CD 5A ED        	CALL	GETNEXT	;yes, open the next one.
EDDB	AF              	XRA	A	;reset next record to read.
EDDC	32 E3 F1        	STA	SAVNREC
EDDF	3A 45 E7        	LDA	STATUS	;check on open, successful?
EDE2	B7              	ORA	A
EDE3	C2 FB ED        	JNZ	RDSEQ3	;no, error.
EDE6	CD 77 E8        RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
EDE9	CD 84 E8        	CALL	CHKBLK	;check it. Within bounds?
EDEC	CA FB ED        	JZ	RDSEQ3	;no, error.
EDEF	CD 8A E8        	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
EDF2	CD D1 E7        	CALL	TRKSEC1	;set the track and sector for this block #.
EDF5	CD B2 E7        	CALL	DOREAD	;and read it.
EDF8	C3 D2 E8        	JMP	SETNREC	;and set the next record to be accessed.
	                ;
	                ;   Read error occured. Set status and return.
	                ;
EDFB	C3 05 E7        RDSEQ3	JMP	IOERR1
	                ;
	                ;   Write the next sequential record.
	                ;
EDFE	3E 01           WTSEQ	MVI	A,1	;set sequential access mode.
EE00	32 D5 F1        	STA	MODE
EE03	3E 00           WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
EE05	32 D3 F1        	STA	RDWRTFLG
EE08	CD 54 E9        	CALL	CHKWPRT	;check write protect status.
EE0B	2A 43 E7        	LHLD	PARAMS
EE0E	CD 47 E9        	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
EE11	CD BB E8        	CALL	STRDATA	;put updated data into fcb.
EE14	3A E3 F1        	LDA	SAVNREC	;get record number to write.
EE17	FE 80           	CPI	128	;within range?
EE19	D2 05 E7        	JNC	IOERR1	;no, error(?).
EE1C	CD 77 E8        	CALL	COMBLK	;compute block number.
EE1F	CD 84 E8        	CALL	CHKBLK	;check number.
EE22	0E 00           	MVI	C,0	;is there one to write to?
EE24	C2 6E EE        	JNZ	WTSEQ6	;yes, go do it.
EE27	CD 3E E8        	CALL	GETBLOCK;get next block number within fcb to use.
EE2A	32 D7 F1        	STA	RELBLOCK;and save.
EE2D	01 00 00        	LXI	B,0	;start looking for space from the start
EE30	B7              	ORA	A	;if none allocated as yet.
EE31	CA 3B EE        	JZ	WTSEQ2
EE34	4F              	MOV	C,A	;extract previous block number from fcb
EE35	0B              	DCX	B	;so we can be closest to it.
EE36	CD 5E E8        	CALL	EXTBLK
EE39	44              	MOV	B,H
EE3A	4D              	MOV	C,L
EE3B	CD BE EB        WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
EE3E	7D              	MOV	A,L	;check for a zero number.
EE3F	B4              	ORA	H
EE40	C2 48 EE        	JNZ	WTSEQ3
EE43	3E 02           	MVI	A,2	;no more space?
EE45	C3 01 E7        	JMP	SETSTAT
EE48	22 E5 F1        WTSEQ3	SHLD	BLKNMBR	;save block number to access.
EE4B	EB              	XCHG		;put block number into (DE).
EE4C	2A 43 E7        	LHLD	PARAMS	;now we must update the fcb for this
EE4F	01 10 00        	LXI	B,16	;newly allocated block.
EE52	09              	DAD	B
EE53	3A DD F1        	LDA	BIGDISK	;8 or 16 bit block numbers?
EE56	B7              	ORA	A
EE57	3A D7 F1        	LDA	RELBLOCK	;(* update this entry *)
EE5A	CA 64 EE        	JZ	WTSEQ4	;zero means 16 bit ones.
EE5D	CD 64 E9        	CALL	ADDA2HL	;(HL)=(HL)+(A)
EE60	73              	MOV	M,E	;store new block number.
EE61	C3 6C EE        	JMP	WTSEQ5
EE64	4F              WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
EE65	06 00           	MVI	B,0
EE67	09              	DAD	B
EE68	09              	DAD	B
EE69	73              	MOV	M,E	;stuff block number (DE) there.
EE6A	23              	INX	H
EE6B	72              	MOV	M,D
EE6C	0E 02           WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
EE6E	3A 45 E7        WTSEQ6	LDA	STATUS	;are we ok so far?
EE71	B7              	ORA	A
EE72	C0              	RNZ
EE73	C5              	PUSH	B	;yes, save write flag for bios (register C).
EE74	CD 8A E8        	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
EE77	3A D5 F1        	LDA	MODE	;get access mode flag (1=sequential,
EE7A	3D              	DCR	A	;0=random, 2=special?).
EE7B	3D              	DCR	A
EE7C	C2 BB EE        	JNZ	WTSEQ9
	                ;
	                ;   Special random i/o from function #40. Maybe for M/PM, but the
	                ; current block, if it has not been written to, will be zeroed
	                ; out and then written (reason?).
	                ;
EE7F	C1              	POP	B
EE80	C5              	PUSH	B
EE81	79              	MOV	A,C	;get write status flag (2=writing unused space).
EE82	3D              	DCR	A
EE83	3D              	DCR	A
EE84	C2 BB EE        	JNZ	WTSEQ9
EE87	E5              	PUSH	H
EE88	2A B9 F1        	LHLD	DIRBUF	;zero out the directory buffer.
EE8B	57              	MOV	D,A	;note that (A) is zero here.
EE8C	77              WTSEQ7	MOV	M,A
EE8D	23              	INX	H
EE8E	14              	INR	D	;do 128 bytes.
EE8F	F2 8C EE        	JP	WTSEQ7
EE92	CD E0 E9        	CALL	DIRDMA	;tell the bios the dma address for directory access.
EE95	2A E7 F1        	LHLD	LOGSECT	;get sector that starts current block.
EE98	0E 02           	MVI	C,2	;set 'writing to unused space' flag.
EE9A	22 E5 F1        WTSEQ8	SHLD	BLKNMBR	;save sector to write.
EE9D	C5              	PUSH	B
EE9E	CD D1 E7        	CALL	TRKSEC1	;determine its track and sector numbers.
EEA1	C1              	POP	B
EEA2	CD B8 E7        	CALL	DOWRITE	;now write out 128 bytes of zeros.
EEA5	2A E5 F1        	LHLD	BLKNMBR	;get sector number.
EEA8	0E 00           	MVI	C,0	;set normal write flag.
EEAA	3A C4 F1        	LDA	BLKMASK	;determine if we have written the entire
EEAD	47              	MOV	B,A	;physical block.
EEAE	A5              	ANA	L
EEAF	B8              	CMP	B
EEB0	23              	INX	H	;prepare for the next one.
EEB1	C2 9A EE        	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
EEB4	E1              	POP	H	;reset next sector number.
EEB5	22 E5 F1        	SHLD	BLKNMBR
EEB8	CD DA E9        	CALL	DEFDMA	;and reset dma address.
	                ;
	                ;   Normal disk write. Set the desired track and sector then
	                ; do the actual write.
	                ;
EEBB	CD D1 E7        WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
EEBE	C1              	POP	B	;get write status flag.
EEBF	C5              	PUSH	B
EEC0	CD B8 E7        	CALL	DOWRITE	;and write this out.
EEC3	C1              	POP	B
EEC4	3A E3 F1        	LDA	SAVNREC	;get number of records in file.
EEC7	21 E1 F1        	LXI	H,SAVNXT;get last record written.
EECA	BE              	CMP	M
EECB	DA D2 EE        	JC	WTSEQ10
EECE	77              	MOV	M,A	;we have to update record count.
EECF	34              	INR	M
EED0	0E 02           	MVI	C,2
	                ;
	                ;*   This area has been patched to correct disk update problem
	                ;* when using blocking and de-blocking in the BIOS.
	                ;
EED2	00              WTSEQ10	NOP		;was 'dcr c'
EED3	00              	NOP		;was 'dcr c'
EED4	21 00 00        	LXI	H,0	;was 'jnz wtseq99'
	                ;
	                ; *   End of patch.
	                ;
EED7	F5              	PUSH	PSW
EED8	CD 69 E9        	CALL	GETS2	;set 'extent written to' flag.
EEDB	E6 7F           	ANI	7FH	;(* clear bit 7 *)
EEDD	77              	MOV	M,A
EEDE	F1              	POP	PSW	;get record count for this extent.
EEDF	FE 7F           WTSEQ99	CPI	127	;is it full?
EEE1	C2 00 EF        	JNZ	WTSEQ12
EEE4	3A D5 F1        	LDA	MODE	;yes, are we in sequential mode?
EEE7	FE 01           	CPI	1
EEE9	C2 00 EF        	JNZ	WTSEQ12
EEEC	CD D2 E8        	CALL	SETNREC	;yes, set next record number.
EEEF	CD 5A ED        	CALL	GETNEXT	;and get next empty space in directory.
EEF2	21 45 E7        	LXI	H,STATUS;ok?
EEF5	7E              	MOV	A,M
EEF6	B7              	ORA	A
EEF7	C2 FE EE        	JNZ	WTSEQ11
EEFA	3D              	DCR	A	;yes, set record count to -1.
EEFB	32 E3 F1        	STA	SAVNREC
EEFE	36 00           WTSEQ11	MVI	M,0	;clear status.
EF00	C3 D2 E8        WTSEQ12	JMP	SETNREC	;set next record to access.
	                ;
	                ;   For random i/o, set the fcb for the desired record number
	                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
	                ; used as follows:
	                ;
	                ;       fcb+35            fcb+34            fcb+33
	                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
	                ;  |7             0 | 7             0 | 7             0|
	                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
	                ;  |    overflow   | | extra |  extent   |   record #  |
	                ;  | ______________| |_extent|__number___|_____________|
	                ;                     also 's2'
	                ;
	                ;   On entry, register (C) contains 0ffh if this is a read
	                ; and thus we can not access unwritten disk space. Otherwise,
	                ; another extent will be opened (for writing) if required.
	                ;
EF03	AF              POSITION:XRA	A	;set random i/o flag.
EF04	32 D5 F1        	STA	MODE
	                ;
	                ;   Special entry (function #40). M/PM ?
	                ;
EF07	C5              POSITN1	PUSH	B	;save read/write flag.
EF08	2A 43 E7        	LHLD	PARAMS	;get address of fcb.
EF0B	EB              	XCHG
EF0C	21 21 00        	LXI	H,33	;now get byte 'r0'.
EF0F	19              	DAD	D
EF10	7E              	MOV	A,M
EF11	E6 7F           	ANI	7FH	;keep bits 0-6 for the record number to access.
EF13	F5              	PUSH	PSW
EF14	7E              	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF15	17              	RAL
EF16	23              	INX	H
EF17	7E              	MOV	A,M
EF18	17              	RAL
EF19	E6 1F           	ANI	1FH	;and save this in bits 0-4 of (C).
EF1B	4F              	MOV	C,A	;this is the extent byte.
EF1C	7E              	MOV	A,M	;now get the extra extent byte.
EF1D	1F              	RAR
EF1E	1F              	RAR
EF1F	1F              	RAR
EF20	1F              	RAR
EF21	E6 0F           	ANI	0FH
EF23	47              	MOV	B,A	;and save it in (B).
EF24	F1              	POP	PSW	;get record number back to (A).
EF25	23              	INX	H	;check overflow byte 'r2'.
EF26	6E              	MOV	L,M
EF27	2C              	INR	L
EF28	2D              	DCR	L
EF29	2E 06           	MVI	L,6	;prepare for error.
EF2B	C2 8B EF        	JNZ	POSITN5	;out of disk space error.
EF2E	21 20 00        	LXI	H,32	;store record number into fcb.
EF31	19              	DAD	D
EF32	77              	MOV	M,A
EF33	21 0C 00        	LXI	H,12	;and now check the extent byte.
EF36	19              	DAD	D
EF37	79              	MOV	A,C
EF38	96              	SUB	M	;same extent as before?
EF39	C2 47 EF        	JNZ	POSITN2
EF3C	21 0E 00        	LXI	H,14	;yes, check extra extent byte 's2' also.
EF3F	19              	DAD	D
EF40	78              	MOV	A,B
EF41	96              	SUB	M
EF42	E6 7F           	ANI	7FH
EF44	CA 7F EF        	JZ	POSITN3;same, we are almost done then.
	                ;
	                ;  Get here when another extent is required.
	                ;
EF47	C5              POSITN2	PUSH	B
EF48	D5              	PUSH	D
EF49	CD A2 EC        	CALL	CLOSEIT	;close current extent.
EF4C	D1              	POP	D
EF4D	C1              	POP	B
EF4E	2E 03           	MVI	L,3	;prepare for error.
EF50	3A 45 E7        	LDA	STATUS
EF53	3C              	INR	A
EF54	CA 84 EF        	JZ	POSITN4	;close error.
EF57	21 0C 00        	LXI	H,12	;put desired extent into fcb now.
EF5A	19              	DAD	D
EF5B	71              	MOV	M,C
EF5C	21 0E 00        	LXI	H,14	;and store extra extent byte 's2'.
EF5F	19              	DAD	D
EF60	70              	MOV	M,B
EF61	CD 51 EC        	CALL	OPENIT	;try and get this extent.
EF64	3A 45 E7        	LDA	STATUS	;was it there?
EF67	3C              	INR	A
EF68	C2 7F EF        	JNZ	POSITN3
EF6B	C1              	POP	B	;no. can we create a new one (writing?).
EF6C	C5              	PUSH	B
EF6D	2E 04           	MVI	L,4	;prepare for error.
EF6F	0C              	INR	C
EF70	CA 84 EF        	JZ	POSITN4	;nope, reading unwritten space error.
EF73	CD 24 ED        	CALL	GETEMPTY;yes we can, try to find space.
EF76	2E 05           	MVI	L,5	;prepare for error.
EF78	3A 45 E7        	LDA	STATUS
EF7B	3C              	INR	A
EF7C	CA 84 EF        	JZ	POSITN4	;out of space?
	                ;
	                ;   Normal return location. Clear error code and return.
	                ;
EF7F	C1              POSITN3	POP	B	;restore stack.
EF80	AF              	XRA	A	;and clear error code byte.
EF81	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Error. Set the 's2' byte to indicate this (why?).
	                ;
EF84	E5              POSITN4	PUSH	H
EF85	CD 69 E9        	CALL	GETS2
EF88	36 C0           	MVI	M,0C0H
EF8A	E1              	POP	H
	                ;
	                ;   Return with error code (presently in L).
	                ;
EF8B	C1              POSITN5	POP	B
EF8C	7D              	MOV	A,L	;get error code.
EF8D	32 45 E7        	STA	STATUS
EF90	C3 78 E9        	JMP	SETS2B7
	                ;
	                ;   Read a random record.
	                ;
EF93	0E FF           READRAN	MVI	C,0FFH	;set 'read' status.
EF95	CD 03 EF        	CALL	POSITION;position the file to proper record.
EF98	CC C1 ED        	CZ	RDSEQ1	;and read it as usual (if no errors).
EF9B	C9              	RET
	                ;
	                ;   Write to a random record.
	                ;
EF9C	0E 00           WRITERAN:MVI	C,0	;set 'writing' flag.
EF9E	CD 03 EF        	CALL	POSITION;position the file to proper record.
EFA1	CC 03 EE        	CZ	WTSEQ1	;and write as usual (if no errors).
EFA4	C9              	RET
	                ;
	                ;   Compute the random record number. Enter with (HL) pointing
	                ; to a fcb an (DE) contains a relative location of a record
	                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
	                ; byte, and (A) the 'r2' byte.
	                ;
	                ;   On return, the zero flag is set if the record is within
	                ; bounds. Otherwise, an overflow occured.
	                ;
EFA5	EB              COMPRAND:XCHG		;save fcb pointer in (DE).
EFA6	19              	DAD	D	;compute relative position of record #.
EFA7	4E              	MOV	C,M	;get record number into (BC).
EFA8	06 00           	MVI	B,0
EFAA	21 0C 00        	LXI	H,12	;now get extent.
EFAD	19              	DAD	D
EFAE	7E              	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
EFAF	0F              	RRC		;move lower bit into bit 7.
EFB0	E6 80           	ANI	80H	;and ignore all other bits.
EFB2	81              	ADD	C	;add to our record number.
EFB3	4F              	MOV	C,A
EFB4	3E 00           	MVI	A,0	;take care of any carry.
EFB6	88              	ADC	B
EFB7	47              	MOV	B,A
EFB8	7E              	MOV	A,M	;now get the upper bits of extent into
EFB9	0F              	RRC		;bit positions 0-3.
EFBA	E6 0F           	ANI	0FH	;and ignore all others.
EFBC	80              	ADD	B	;add this in to 'r1' byte.
EFBD	47              	MOV	B,A
EFBE	21 0E 00        	LXI	H,14	;get the 's2' byte (extra extent).
EFC1	19              	DAD	D
EFC2	7E              	MOV	A,M
EFC3	87              	ADD	A	;and shift it left 4 bits (bits 4-7).
EFC4	87              	ADD	A
EFC5	87              	ADD	A
EFC6	87              	ADD	A
EFC7	F5              	PUSH	PSW	;save carry flag (bit 0 of flag byte).
EFC8	80              	ADD	B	;now add extra extent into 'r1'.
EFC9	47              	MOV	B,A
EFCA	F5              	PUSH	PSW	;and save carry (overflow byte 'r2').
EFCB	E1              	POP	H	;bit 0 of (L) is the overflow indicator.
EFCC	7D              	MOV	A,L
EFCD	E1              	POP	H	;and same for first carry flag.
EFCE	B5              	ORA	L	;either one of these set?
EFCF	E6 01           	ANI	01H	;only check the carry flags.
EFD1	C9              	RET
	                ;
	                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
	                ; reflect the last record used for a random (or other) file.
	                ; This reads the directory and looks at all extents computing
	                ; the largerst record number for each and keeping the maximum
	                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
	                ; maximum record number. This is used to compute the space used
	                ; by a random file.
	                ;
EFD2	0E 0C           RANSIZE	MVI	C,12	;look thru directory for first entry with
EFD4	CD 18 EB        	CALL	FINDFST	;this name.
EFD7	2A 43 E7        	LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
EFDA	11 21 00        	LXI	D,33
EFDD	19              	DAD	D
EFDE	E5              	PUSH	H
EFDF	72              	MOV	M,D	;note that (D)=0.
EFE0	23              	INX	H
EFE1	72              	MOV	M,D
EFE2	23              	INX	H
EFE3	72              	MOV	M,D
EFE4	CD F5 E9        RANSIZ1	CALL	CKFILPOS;is there an extent to process?
EFE7	CA 0C F0        	JZ	RANSIZ3	;no, we are done.
EFEA	CD 5E E9        	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
EFED	11 0F 00        	LXI	D,15	;point to last record in extent.
EFF0	CD A5 EF        	CALL	COMPRAND;and compute random parameters.
EFF3	E1              	POP	H
EFF4	E5              	PUSH	H	;now check these values against those
EFF5	5F              	MOV	E,A	;already in fcb.
EFF6	79              	MOV	A,C	;the carry flag will be set if those
EFF7	96              	SUB	M	;in the fcb represent a larger size than
EFF8	23              	INX	H	;this extent does.
EFF9	78              	MOV	A,B
EFFA	9E              	SBB	M
EFFB	23              	INX	H
EFFC	7B              	MOV	A,E
EFFD	9E              	SBB	M
EFFE	DA 06 F0        	JC	RANSIZ2
F001	73              	MOV	M,E	;we found a larger (in size) extent.
F002	2B              	DCX	H	;stuff these values into fcb.
F003	70              	MOV	M,B
F004	2B              	DCX	H
F005	71              	MOV	M,C
F006	CD 2D EB        RANSIZ2	CALL	FINDNXT	;now get the next extent.
F009	C3 E4 EF        	JMP	RANSIZ1	;continue til all done.
F00C	E1              RANSIZ3	POP	H	;we are done, restore the stack and
F00D	C9              	RET		;return.
	                ;
	                ;   Function to return the random record position of a given
	                ; file which has been read in sequential mode up to now.
	                ;
F00E	2A 43 E7        SETRAN	LHLD	PARAMS	;point to fcb.
F011	11 20 00        	LXI	D,32	;and to last used record.
F014	CD A5 EF        	CALL	COMPRAND;compute random position.
F017	21 21 00        	LXI	H,33	;now stuff these values into fcb.
F01A	19              	DAD	D
F01B	71              	MOV	M,C	;move 'r0'.
F01C	23              	INX	H
F01D	70              	MOV	M,B	;and 'r1'.
F01E	23              	INX	H
F01F	77              	MOV	M,A	;and lastly 'r2'.
F020	C9              	RET
	                ;
	                ;   This routine select the drive specified in (ACTIVE) and
	                ; update the login vector and bitmap table if this drive was
	                ; not already active.
	                ;
F021	2A AF F1        LOGINDRV:LHLD	LOGIN	;get the login vector.
F024	3A 42 E7        	LDA	ACTIVE	;get the default drive.
F027	4F              	MOV	C,A
F028	CD EA E8        	CALL	SHIFTR	;position active bit for this drive
F02B	E5              	PUSH	H	;into bit 0.
F02C	EB              	XCHG
F02D	CD 59 E7        	CALL	SELECT	;select this drive.
F030	E1              	POP	H
F031	CC 47 E7        	CZ	SLCTERR	;valid drive?
F034	7D              	MOV	A,L	;is this a newly activated drive?
F035	1F              	RAR
F036	D8              	RC
F037	2A AF F1        	LHLD	LOGIN	;yes, update the login vector.
F03A	4D              	MOV	C,L
F03B	44              	MOV	B,H
F03C	CD 0B E9        	CALL	SETBIT
F03F	22 AF F1        	SHLD	LOGIN	;and save.
F042	C3 A3 EA        	JMP	BITMAP	;now update the bitmap.
	                ;
	                ;   Function to set the active disk number.
	                ;
F045	3A D6 F1        SETDSK	LDA	EPARAM	;get parameter passed and see if this
F048	21 42 E7        	LXI	H,ACTIVE;represents a change in drives.
F04B	BE              	CMP	M
F04C	C8              	RZ
F04D	77              	MOV	M,A	;yes it does, log it in.
F04E	C3 21 F0        	JMP	LOGINDRV
	                ;
	                ;   This is the 'auto disk select' routine. The firsst byte
	                ; of the fcb is examined for a drive specification. If non
	                ; zero then the drive will be selected and loged in.
	                ;
F051	3E FF           AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
F053	32 DE F1        	STA	AUTO
F056	2A 43 E7        	LHLD	PARAMS	;get drive specified.
F059	7E              	MOV	A,M
F05A	E6 1F           	ANI	1FH	;look at lower 5 bits.
F05C	3D              	DCR	A	;adjust for (1=A, 2=B) etc.
F05D	32 D6 F1        	STA	EPARAM	;and save for the select routine.
F060	FE 1E           	CPI	1EH	;check for 'no change' condition.
F062	D2 75 F0        	JNC	AUTOSL1	;yes, don't change.
F065	3A 42 E7        	LDA	ACTIVE	;we must change, save currently active
F068	32 DF F1        	STA	OLDDRV	;drive.
F06B	7E              	MOV	A,M	;and save first byte of fcb also.
F06C	32 E0 F1        	STA	AUTOFLAG;this must be non-zero.
F06F	E6 E0           	ANI	0E0H	;whats this for (bits 6,7 are used for
F071	77              	MOV	M,A	;something)?
F072	CD 45 F0        	CALL	SETDSK	;select and log in this drive.
F075	3A 41 E7        AUTOSL1	LDA	USERNO	;move user number into fcb.
F078	2A 43 E7        	LHLD	PARAMS	;(* upper half of first byte *)
F07B	B6              	ORA	M
F07C	77              	MOV	M,A
F07D	C9              	RET		;and return (all done).
	                ;
	                ;   Function to return the current cp/m version number.
	                ;
F07E	3E 22           GETVER	MVI	A,022h	;version 2.2
F080	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Function to reset the disk system.
	                ;
F083	21 00 00        RSTDSK	LXI	H,0	;clear write protect status and log
F086	22 AD F1        	SHLD	WRTPRT	;in vector.
F089	22 AF F1        	SHLD	LOGIN
F08C	AF              	XRA	A	;select drive 'A'.
F08D	32 42 E7        	STA	ACTIVE
F090	21 80 00        	LXI	H,TBUFF	;setup default dma address.
F093	22 B1 F1        	SHLD	USERDMA
F096	CD DA E9        	CALL	DEFDMA
F099	C3 21 F0        	JMP	LOGINDRV;now log in drive 'A'.
	                ;
	                ;   Function to open a specified file.
	                ;
F09C	CD 72 E9        OPENFIL	CALL	CLEARS2	;clear 's2' byte.
F09F	CD 51 F0        	CALL	AUTOSEL	;select proper disk.
F0A2	C3 51 EC        	JMP	OPENIT	;and open the file.
	                ;
	                ;   Function to close a specified file.
	                ;
F0A5	CD 51 F0        CLOSEFIL:CALL	AUTOSEL	;select proper disk.
F0A8	C3 A2 EC        	JMP	CLOSEIT	;and close the file.
	                ;
	                ;   Function to return the first occurence of a specified file
	                ; name. If the first byte of the fcb is '?' then the name will
	                ; not be checked (get the first entry no matter what).
	                ;
F0AB	0E 00           GETFST	MVI	C,0	;prepare for special search.
F0AD	EB              	XCHG
F0AE	7E              	MOV	A,M	;is first byte a '?'?
F0AF	FE 3F           	CPI	'?'
F0B1	CA C2 F0        	JZ	GETFST1	;yes, just get very first entry (zero length match).
F0B4	CD A6 E8        	CALL	SETEXT	;get the extension byte from fcb.
F0B7	7E              	MOV	A,M	;is it '?'? if yes, then we want
F0B8	FE 3F           	CPI	'?'	;an entry with a specific 's2' byte.
F0BA	C4 72 E9        	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
F0BD	CD 51 F0        	CALL	AUTOSEL	;select proper drive.
F0C0	0E 0F           	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
F0C2	CD 18 EB        GETFST1	CALL	FINDFST	;find an entry and then move it into
F0C5	C3 E9 E9        	JMP	MOVEDIR	;the users dma space.
	                ;
	                ;   Function to return the next occurence of a file name.
	                ;
F0C8	2A D9 F1        GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
F0CB	22 43 E7        	SHLD	PARAMS	;other dbos calls are allowed.
F0CE	CD 51 F0        	CALL	AUTOSEL	;no error will be returned, but the
F0D1	CD 2D EB        	CALL	FINDNXT	;results will be wrong.
F0D4	C3 E9 E9        	JMP	MOVEDIR
	                ;
	                ;   Function to delete a file by name.
	                ;
F0D7	CD 51 F0        DELFILE	CALL	AUTOSEL	;select proper drive.
F0DA	CD 9C EB        	CALL	ERAFILE	;erase the file.
F0DD	C3 01 EB        	JMP	STSTATUS;set status and return.
	                ;
	                ;   Function to execute a sequential read of the specified
	                ; record number.
	                ;
F0E0	CD 51 F0        READSEQ	CALL	AUTOSEL	;select proper drive then read.
F0E3	C3 BC ED        	JMP	RDSEQ
	                ;
	                ;   Function to write the net sequential record.
	                ;
F0E6	CD 51 F0        WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
F0E9	C3 FE ED        	JMP	WTSEQ
	                ;
	                ;   Create a file function.
	                ;
F0EC	CD 72 E9        FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
F0EF	CD 51 F0        	CALL	AUTOSEL	;select proper drive and get the next
F0F2	C3 24 ED        	JMP	GETEMPTY;empty directory space.
	                ;
	                ;   Function to rename a file.
	                ;
F0F5	CD 51 F0        RENFILE	CALL	AUTOSEL	;select proper drive and then switch
F0F8	CD 16 EC        	CALL	CHGNAMES;file names.
F0FB	C3 01 EB        	JMP	STSTATUS
	                ;
	                ;   Function to return the login vector.
	                ;
F0FE	2A AF F1        GETLOG	LHLD	LOGIN
F101	C3 29 F1        	JMP	GETPRM1
	                ;
	                ;   Function to return the current disk assignment.
	                ;
F104	3A 42 E7        GETCRNT	LDA	ACTIVE
F107	C3 01 E7        	JMP	SETSTAT
	                ;
	                ;   Function to set the dma address.
	                ;
F10A	EB              PUTDMA	XCHG
F10B	22 B1 F1        	SHLD	USERDMA	;save in our space and then get to
F10E	C3 DA E9        	JMP	DEFDMA	;the bios with this also.
	                ;
	                ;   Function to return the allocation vector.
	                ;
F111	2A BF F1        GETALOC	LHLD	ALOCVECT
F114	C3 29 F1        	JMP	GETPRM1
	                ;
	                ;   Function to return the read-only status vector.
	                ;
F117	2A AD F1        GETROV	LHLD	WRTPRT
F11A	C3 29 F1        	JMP	GETPRM1
	                ;
	                ;   Function to set the file attributes (read-only, system).
	                ;
F11D	CD 51 F0        SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
F120	CD 3B EC        	CALL	SAVEATTR
F123	C3 01 EB        	JMP	STSTATUS
	                ;
	                ;   Function to return the address of the disk parameter block
	                ; for the current drive.
	                ;
F126	2A BB F1        GETPARM	LHLD	DISKPB
F129	22 45 E7        GETPRM1	SHLD	STATUS
F12C	C9              	RET
	                ;
	                ;   Function to get or set the user number. If (E) was (FF)
	                ; then this is a request to return the current user number.
	                ; Else set the user number from (E).
	                ;
F12D	3A D6 F1        GETUSER	LDA	EPARAM	;get parameter.
F130	FE FF           	CPI	0FFH	;get user number?
F132	C2 3B F1        	JNZ	SETUSER
F135	3A 41 E7        	LDA	USERNO	;yes, just do it.
F138	C3 01 E7        	JMP	SETSTAT
F13B	E6 1F           SETUSER	ANI	1FH	;no, we should set it instead. keep low
F13D	32 41 E7        	STA	USERNO	;bits (0-4) only.
F140	C9              	RET
	                ;
	                ;   Function to read a random record from a file.
	                ;
F141	CD 51 F0        RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
F144	C3 93 EF        	JMP	READRAN
	                ;
	                ;   Function to compute the file size for random files.
	                ;
F147	CD 51 F0        WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
F14A	C3 9C EF        	JMP	WRITERAN
	                ;
	                ;   Function to compute the size of a random file.
	                ;
F14D	CD 51 F0        FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
F150	C3 D2 EF        	JMP	RANSIZE
	                ;
	                ;   Function #37. This allows a program to log off any drives.
	                ; On entry, set (DE) to contain a word with bits set for those
	                ; drives that are to be logged off. The log-in vector and the
	                ; write protect vector will be updated. This must be a M/PM
	                ; special function.
	                ;
F153	2A 43 E7        LOGOFF	LHLD	PARAMS	;get drives to log off.
F156	7D              	MOV	A,L	;for each bit that is set, we want
F157	2F              	CMA		;to clear that bit in (LOGIN)
F158	5F              	MOV	E,A	;and (WRTPRT).
F159	7C              	MOV	A,H
F15A	2F              	CMA
F15B	2A AF F1        	LHLD	LOGIN	;reset the login vector.
F15E	A4              	ANA	H
F15F	57              	MOV	D,A
F160	7D              	MOV	A,L
F161	A3              	ANA	E
F162	5F              	MOV	E,A
F163	2A AD F1        	LHLD	WRTPRT
F166	EB              	XCHG
F167	22 AF F1        	SHLD	LOGIN	;and save.
F16A	7D              	MOV	A,L	;now do the write protect vector.
F16B	A3              	ANA	E
F16C	6F              	MOV	L,A
F16D	7C              	MOV	A,H
F16E	A2              	ANA	D
F16F	67              	MOV	H,A
F170	22 AD F1        	SHLD	WRTPRT	;and save. all done.
F173	C9              	RET
	                ;
	                ;   Get here to return to the user.
	                ;
F174	3A DE F1        GOBACK	LDA	AUTO	;was auto select activated?
F177	B7              	ORA	A
F178	CA 91 F1        	JZ	GOBACK1
F17B	2A 43 E7        	LHLD	PARAMS	;yes, but was a change made?
F17E	36 00           	MVI	M,0	;(* reset first byte of fcb *)
F180	3A E0 F1        	LDA	AUTOFLAG
F183	B7              	ORA	A
F184	CA 91 F1        	JZ	GOBACK1
F187	77              	MOV	M,A	;yes, reset first byte properly.
F188	3A DF F1        	LDA	OLDDRV	;and get the old drive and select it.
F18B	32 D6 F1        	STA	EPARAM
F18E	CD 45 F0        	CALL	SETDSK
F191	2A 0F E7        GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
F194	F9              	SPHL
F195	2A 45 E7        	LHLD	STATUS	;get return status.
F198	7D              	MOV	A,L	;force version 1.4 compatability.
F199	44              	MOV	B,H
F19A	C9              	RET		;and go back to user.
	                ;
	                ;   Function #40. This is a special entry to do random i/o.
	                ; For the case where we are writing to unused disk space, this
	                ; space will be zeroed out first. This must be a M/PM special
	                ; purpose function, because why would any normal program even
	                ; care about the previous contents of a sector about to be
	                ; written over.
	                ;
F19B	CD 51 F0        WTSPECL	CALL	AUTOSEL	;select proper drive.
F19E	3E 02           	MVI	A,2	;use special write mode.
F1A0	32 D5 F1        	STA	MODE
F1A3	0E 00           	MVI	C,0	;set write indicator.
F1A5	CD 07 EF        	CALL	POSITN1	;position the file.
F1A8	CC 03 EE        	CZ	WTSEQ1	;and write (if no errors).
F1AB	C9              	RET
	                ;
	                ;**************************************************************
	                ;*
	                ;*     BDOS data storage pool.
	                ;*
	                ;**************************************************************
	                ;
F1AC	E5              EMPTYFCB:DB	0E5H	;empty directory segment indicator.
F1AD	00 00           WRTPRT	DW	0	;write protect status for all 16 drives.
F1AF	00 00           LOGIN	DW	0	;drive active word (1 bit per drive).
F1B1	80 00           USERDMA	DW	080H	;user's dma address (defaults to 80h).
	                ;
	                ;   Scratch areas from parameter block.
	                ;
F1B3	00 00           SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
F1B5	00 00           SCRATCH2:DW	0	;last selected track number.
F1B7	00 00           SCRATCH3:DW	0	;last selected sector number.
	                ;
	                ;   Disk storage areas from parameter block.
	                ;
F1B9	00 00           DIRBUF	DW	0	;address of directory buffer to use.
F1BB	00 00           DISKPB	DW	0	;contains address of disk parameter block.
F1BD	00 00           CHKVECT	DW	0	;address of check vector.
F1BF	00 00           ALOCVECT:DW	0	;address of allocation vector (bit map).
	                ;
	                ;   Parameter block returned from the bios.
	                ;
F1C1	00 00           SECTORS	DW	0	;sectors per track from bios.
F1C3	00              BLKSHFT	DB	0	;block shift.
F1C4	00              BLKMASK	DB	0	;block mask.
F1C5	00              EXTMASK	DB	0	;extent mask.
F1C6	00 00           DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
F1C8	00 00           DIRSIZE	DW	0	;directory size.
F1CA	00 00           ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
F1CC	00 00           ALLOC1	DW	0
F1CE	00 00           OFFSET	DW	0	;first usable track number.
F1D0	00 00           XLATE	DW	0	;sector translation table address.
	                ;
	                ;
F1D2	00              CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
F1D3	00              RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
F1D4	00              FNDSTAT	DB	0	;filename found status (0=found first entry).
F1D5	00              MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
F1D6	00              EPARAM	DB	0	;storage for register (E) on entry to bdos.
F1D7	00              RELBLOCK:DB	0	;relative position within fcb of block number written.
F1D8	00              COUNTER	DB	0	;byte counter for directory name searches.
F1D9	00 00 00 00     SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
F1DD	00              BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
F1DE	00              AUTO	DB	0	;if non-zero, then auto select activated.
F1DF	00              OLDDRV	DB	0	;on auto select, storage for previous drive.
F1E0	00              AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
F1E1	00              SAVNXT	DB	0	;storage for next record number to access.
F1E2	00              SAVEXT	DB	0	;storage for extent number of file.
F1E3	00 00           SAVNREC	DW	0	;storage for number of records in file.
F1E5	00 00           BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
F1E7	00 00           LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
F1E9	00              FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
F1EA	00 00           FILEPOS	DW	0	;files position within directory (0 to max entries -1).
	                ;
	                ;   Disk directory buffer checksum bytes. One for each of the
	                ; 16 possible drives.
	                ;
F1EC	00 00 00 00     CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	. . .
F1F8	00 00 00 00 

	                ;
	                ;   Extra space ?
	                ;
F1FC	00 00 00 00     	DB	0,0,0,0
	                ;
	                ;**************************************************************
	                ;*
	                ;*        B I O S   J U M P   T A B L E
	                ;*
	                ;**************************************************************
	                ;
F200	C3 00 00        BOOT	JMP	0	;NOTE WE USE FAKE DESTINATIONS
F203	C3 00 00        WBOOT	JMP	0
F206	C3 00 00        CONST	JMP	0
F209	C3 00 00        CONIN	JMP	0
F20C	C3 00 00        CONOUT	JMP	0
F20F	C3 00 00        LIST	JMP	0
F212	C3 00 00        PUNCH	JMP	0
F215	C3 00 00        READER	JMP	0
F218	C3 00 00        HOME	JMP	0
F21B	C3 00 00        SELDSK	JMP	0
F21E	C3 00 00        SETTRK	JMP	0
F221	C3 00 00        SETSEC	JMP	0
F224	C3 00 00        SETDMA	JMP	0
F227	C3 00 00        READ	JMP	0
F22A	C3 00 00        WRITE	JMP	0
F22D	C3 00 00        PRSTAT	JMP	0
F230	C3 00 00        SECTRN	JMP	0
	                ;
	                ;*
	                ;******************   E N D   O F   C P / M   *****************
	                ;*
	                
	                
Labels:
active                  E742
adda2hl                 E964	addhl                   DE59
alloc0                  F1CA	alloc1                  F1CC
alocvect                F1BF	auto                    F1DE
autoflag                F1E0	autosel                 F051
autosl1                 F075	backup                  E5A4
backup1                 E5AC	badload                 E37A
badsctr                 E409	badsec                  E4CA
badsel                  E4D5	badslct                 E40B
batch                   E3AB	batchfcb                E3AC
bdosdrv                 E4C6	bdoserr                 E4BA
bigdisk                 F1DD	bitmap                  EAA3
bitmap1                 EAB1	bitmap2                 EAD2
bitmap3                 EAF6	blkmask                 F1C4
blknmbr                 F1E5	blkshft                 F1C3
boot                    F200	bs                      0008
cbase                   DC00	ccpstack                E3AB
cdrive                  E3EF	charbuf                 E70E
check                   DE30	checkdir                E99E
checksum                E8F7	chgdrv                  E3F0
chgnam1                 EC27	chgnames                EC16
chkblk                  E884	chkchar                 E514
chkcon                  DDC2	chkdir1                 E9C4
chknmbr                 E98C	chkrofl                 E944
chksum1                 E8FD	chkvect                 F1BD
chkwprt                 E954	ckbitmap                EA35
ckbmap1                 EA56	ckcon1                  E542
ckcon2                  E545	ckconsol                E523
ckfilpos                E9F5	ckrof1                  E947
cksumtbl                F1EC	clearbuf                DF58
clears2                 E972	close                   DCDA
closefil                F0A5	closeflg                F1D2
closeit                 ECA2	closeit1                ECCD
closeit2                ECDB	closeit3                ECE1
closeit4                ECE8	closeit5                ECFD
closeit6                ED17	closeit7                ED1F
cmdadr                  DFC1	cmdtbl                  DF10
cmmnd1                  DF82	cmmnd2                  DF98
cntrlc                  0003	cntrle                  0005
cntrlp                  0010	cntrlr                  0012
cntrls                  0013	cntrlu                  0015
cntrlx                  0018	cntrlz                  001A
comblk                  E877	comfile                 E383
command                 DF5C	comprand                EFA5
conin                   F209	conout                  F20C
const                   F206	convert                 DE60
convfst                 DE5E	convrt1                 DE89
convrt2                 DE90	convrt3                 DE96
convrt4                 DE98	convrt5                 DEA9
convrt6                 DEAB	convrt7                 DEAF
convrt8                 DEB9	counter                 F1D8
cr                      000D	create                  DD09
crlf                    DC98	curpos                  E70C
de2hl                   E74F	de2hl1                  E750
decode                  DFF8	decode1                 E008
decode2                 E02A	decode3                 E033
decode4                 E03A	defdma                  E9DA
del                     007F	delbatch                DDDD
delete                  DCEF	delfile                 F0D7
dirbuf                  F1B9	dirc1                   E6E0
dircio                  E6D4	dirdma                  E9E0
dirdma1                 E9E3	direct                  E077
direct1                 E088	direct2                 E08F
direct3                 E098	direct4                 E0CC
direct5                 E0D4	direct6                 E0D9
direct7                 E10E	direct8                 E10F
direct9                 E11B	dirread                 E9D4
dirsize                 F1C8	dirwrite                E9C6
diskpb                  F1BB	diskro                  E4E1
dmaset                  DDD8	doread                  E7B2
dowrite                 E7B8	drect63                 E0F7
drect65                 E0F9	dselect                 E054
dsksel                  DCBD	dsksize                 F1C6
emptyfcb                F1AC	entry                   0005
entry1                  DCC3	entry2                  DCF4
eparam                  F1D6	erafil1                 EBA4
erafile                 EB9C	erase                   E11F
erase1                  E142	error1                  E499
error2                  E4A5	error3                  E4AB
error4                  E4B1	error5                  E4B4
exists                  E282	extblk                  E85E
extblk1                 E871	extmask                 F1C5
extract                 E04B	fbase                   E406
fbase1                  E411	fcb                     E3CD
fcb2hl                  E95E	fcbpos                  F1E9
fcbset                  EBFD	fcreate                 F0EC
ff                      000C	filepos                 F1EA
filero                  E4DC	filesize                F14D
findfst                 EB18	findnxt                 EB2D
fndnxt1                 EB4A	fndnxt2                 EB53
fndnxt3                 EB73	fndnxt4                 EB7C
fndnxt5                 EB83	fndnxt6                 EB94
fndspa1                 EBC0	fndspa2                 EBD1
fndspa3                 EBEC	fndspa4                 EBF4
fndspace                EBBE	fndstat                 F1D4
functns                 E447	getaloc                 F111
getback                 E386	getback1                E389
getblk1                 E845	getblk2                 E853
getblk3                 E85C	getblock                E83E
getchar                 E4FB	getcon                  E6C8
getcrnt                 F104	getcsts                 E6FE
getdsk                  DDD0	getecho                 E506
getempty                ED24	getext                  DEC0
getext1                 DEC8	getext2                 DED9
getext3                 DEDB	getext4                 DEDF
getext5                 DEE9	getext6                 DEF0
getext7                 DEF2	getext8                 DF01
getext9                 DF09	getfst                  F0AB
getfst1                 F0C2	getinp                  DD39
getinp1                 DD96	getinp2                 DDA7
getinp3                 DDAB	getinp4                 DDBA
getiob                  E6ED	getlog                  F0FE
getmt1                  ED46	getnext                 ED5A
getnxt                  F0C8	getparm                 F126
getprm1                 F129	getrdr                  E6CE
getrov                  F117	gets2                   E969
getsetuc                DD15	getuser                 F12D
getusr                  DD13	getver                  F07E
getwprt                 E91E	goback                  F174
goback1                 F191	gtnext1                 ED83
gtnext2                 ED8E	gtnext3                 EDAC
gtnext4                 EDAF	gtnext5                 EDB6
halt                    DFCF	hl2de                   E042
home                    F218	homedrv                 E7A1
inbuff                  DC06	inpoint                 DC88
iobyte                  0003	ioerr1                  E705
ioret                   E7BB	jumphl                  E74A
lf                      000A	list                    F20F
logical                 E88A	logicl1                 E890
login                   F1AF	logindrv                F021
logoff                  F153	logsect                 F1E7
mem                     003E	mode                    F1D5
morefls                 E97F	move3                   E040
movecd                  DD29	movedir                 E9E9
moveword                EC94	namepnt                 DC8A
nbytes                  E3F1	newline                 E5B1
newln1                  E5B9	nfuncts                 0029
nofile                  DFF0	nonblank                DE4F
none                    DFEA	nospace                 E207
numcmds                 0006	nxent1                  EA19
nxent2                  EA20	nxentry                 EA05
offset                  F1CE	olddrv                  F1DF
open                    DCCB	openfcb                 DCD0
openfil                 F09C	openit                  EC51
openit1                 EC5A	openit2                 EC8B
outchar                 E548	outchr1                 E562
outchr2                 E579	outcon                  E590
outcon1                 E596	outcrlf                 E5C9
outflag                 E70A	params                  E743
pattrn1                 DF28	pattrn2                 E400
pline                   DCA7	pline2                  DCAC
position                EF03	positn1                 EF07
positn2                 EF47	positn3                 EF7F
positn4                 EF84	positn5                 EF8B
print                   DC8C	printb                  DC92
prstat                  F22D	prterr                  E4E5
prtflag                 E70D	prtmesg                 E5D3
prtstr                  E6F8	punch                   F212
putdma                  F10A	ransiz1                 EFE4
ransiz2                 F006	ransiz3                 F00C
ransize                 EFD2	rdbuf1                  E5EF
rdbuf10                 E670	rdbuf11                 E678
rdbuf12                 E68A	rdbuf13                 E699
rdbuf14                 E6A6	rdbuf15                 E6A9
rdbuf16                 E6BD	rdbuf17                 E6C1
rdbuf2                  E5F1	rdbuf3                  E616
rdbuf4                  E626	rdbuf5                  E637
rdbuf6                  E648	rdbuf7                  E64E
rdbuf8                  E65F	rdbuf9                  E66B
rdbuff                  E5E1	rderr                   DFDF
rderror                 DFD9	rdrandom                F141
rdrec                   DCF9	rdseq                   EDBC
rdseq1                  EDC1	rdseq2                  EDE6
rdseq3                  EDFB	rdwrtflg                F1D3
read                    F227	reader                  F215
readfcb                 DCFE	readran                 EF93
readseq                 F0E0	relblock                F1D7
renam                   DD0E	rename                  E210
rename1                 E23F	rename2                 E259
rename3                 E25E	rename4                 E26D
rename5                 E273	rename6                 E279
renfile                 F0F5	resdsk                  DCB8
resetdr                 E066	rodisk                  E40D
rofile                  E40F	rstdsk                  F083
rtn                     E704	rtncode                 E3EE
samext                  EB07	savatr1                 EC40
save                    E1AD	save1                   E1D4
save2                   E1F1	save3                   E1FB
save4                   E201	saveattr                EC3B
savefcb                 F1D9	savext                  F1E2
savnrec                 F1E3	savnxt                  F1E1
scratch1                F1B3	scratch2                F1B5
scratch3                F1B7	search                  DF2E
search1                 DF33	search2                 DF3C
search3                 DF4F	search4                 DF54
sectors                 F1C1	sectrn                  F230
seldsk                  F21B	select                  E759
select1                 E79D	setattr                 F11D
setbit                  E90B	setcdrv                 DD1A
setdir                  E99C	setdma                  F224
setdsk                  F045	setext                  E8A6
setfile                 EA6B	setfl1                  EA75
setfl2                  EA88	setfl3                  EA8E
setfl4                  EA9D	sethlde                 E8AE
setiob                  E6F3	setnrec                 E8D2
setran                  F00E	sets2b7                 E978
setsec                  F221	setstat                 E701
settrk                  F21E	setuser                 F13B
shiftl                  E904	shiftl1                 E905
shiftr                  E8EA	shiftr1                 E8EB
showit                  E57F	slcterr                 E747
space                   DCA2	srchfcb                 DCE9
srchfst                 DCDF	srchnxt                 DCE4
starting                E70B	status                  E745
stbitmap                EA5C	stbmap1                 EA64
stddma                  DDD5	stfilpos                E9FE
stkarea                 E741	stnrec1                 E8DE
strdata                 E8BB	ststatus                EB01
subhl                   E995	synerr                  DE09
synerr1                 DE0F	synerr2                 DE22
tab                     0009	tbase                   0100
tbuff                   0080	tdrive                  0004
tfcb                    005C	trksec                  E7C3
trksec1                 E7D1	trksec2                 E7E4
trksec3                 E7FA	trksec4                 E80F
type                    E15D	type1                   E174
type2                   E177	type3                   E187
type4                   E1A0	type5                   E1A7
unknown                 E2A5	unkwn0                  E371
unkwn1                  E2C4	unkwn2                  E2CD
unkwn3                  E2E1	unkwn4                  E301
unkwn5                  E330	unkwn6                  E33E
unkwn7                  E343	unkwn8                  E34F
unkwn9                  E36B	update                  EC01
update1                 EC10	upper                   DD30
user                    E28E	userdma                 F1B1
userno                  E741	usrstack                E70F
verify                  DDF5	verify1                 DDFD
wboot                   F203	write                   F22A
writeran                EF9C	wrtprt                  F1AD
wrtprtd                 E92C	wrtrec                  DD04
wrtseq                  F0E6	wtrandom                F147
wtseq                   EDFE	wtseq1                  EE03
wtseq10                 EED2	wtseq11                 EEFE
wtseq12                 EF00	wtseq2                  EE3B
wtseq3                  EE48	wtseq4                  EE64
wtseq5                  EE6C	wtseq6                  EE6E
wtseq7                  EE8C	wtseq8                  EE9A
wtseq9                  EEBB	wtseq99                 EEDF
wtspecl                 F19B	xlate                   F1D0
yesno                   E152	
Memory dump:
 
DC00:  C3 5C DF C3 58 DF 7F 00-43 6F 70 79 72 69 67 68  .\..X...Copyrigh
DC10:  74 20 31 39 37 39 20 28-63 29 20 62 79 20 44 69  t.1979.(c).by.Di
DC20:  67 69 74 61 6C 20 52 65-73 65 61 72 63 68 20 20  gital.Research..
DC30:  20 20 20 20 00 00 00 00-00 00 00 00 00 00 00 00  ................
DC40:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
DC50:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
DC60:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
DC70:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
DC80:  00 00 00 00 00 00 00 00-08 DC 00 00 5F 0E 02 C3  ............_...
DC90:  05 00 C5 CD 8C DC C1 C9-3E 0D CD 92 DC 3E 0A C3  ........>....>..
DCA0:  92 DC 3E 20 C3 92 DC C5-CD 98 DC E1 7E B7 C8 23  ..>.........~..#
DCB0:  E5 CD 8C DC E1 C3 AC DC-0E 0D C3 05 00 5F 0E 0E  ............._..
DCC0:  C3 05 00 CD 05 00 32 EE-E3 3C C9 0E 0F C3 C3 DC  ......2..<......
DCD0:  AF 32 ED E3 11 CD E3 C3-CB DC 0E 10 C3 C3 DC 0E  .2..............
DCE0:  11 C3 C3 DC 0E 12 C3 C3-DC 11 CD E3 C3 DF DC 0E  ................
DCF0:  13 C3 05 00 CD 05 00 B7-C9 0E 14 C3 F4 DC 11 CD  ................
DD00:  E3 C3 F9 DC 0E 15 C3 F4-DC 0E 16 C3 C3 DC 0E 17  ................
DD10:  C3 05 00 1E FF 0E 20 C3-05 00 CD 13 DD 87 87 87  ................
DD20:  87 21 EF E3 B6 32 04 00-C9 3A EF E3 32 04 00 C9  .!...2...:..2...
DD30:  FE 61 D8 FE 7B D0 E6 5F-C9 3A AB E3 B7 CA 96 DD  .a..{.._.:......
DD40:  3A EF E3 B7 3E 00 C4 BD-DC 11 AC E3 CD CB DC CA  :...>...........
DD50:  96 DD 3A BB E3 3D 32 CC-E3 11 AC E3 CD F9 DC C2  ..:..=2.........
DD60:  96 DD 11 07 DC 21 80 00-06 80 CD 42 E0 21 BA E3  .....!.....B.!..
DD70:  36 00 23 35 11 AC E3 CD-DA DC CA 96 DD 3A EF E3  6.#5.........:..
DD80:  B7 C4 BD DC 21 08 DC CD-AC DC CD C2 DD CA A7 DD  ....!...........
DD90:  CD DD DD C3 82 DF CD DD-DD CD 1A DD 0E 0A 11 06  ................
DDA0:  DC CD 05 00 CD 29 DD 21-07 DC 46 23 78 B7 CA BA  .....).!..F#x...
DDB0:  DD 7E CD 30 DD 77 05 C3-AB DD 77 21 08 DC 22 88  .~.0.w....w!..".
DDC0:  DC C9 0E 0B CD 05 00 B7-C8 0E 01 CD 05 00 B7 C9  ................
DDD0:  0E 19 C3 05 00 11 80 00-0E 1A C3 05 00 21 AB E3  .............!..
DDE0:  7E B7 C8 36 00 AF CD BD-DC 11 AC E3 CD EF DC 3A  ~..6...........:
DDF0:  EF E3 C3 BD DC 11 28 DF-21 00 E4 06 06 1A BE C2  ......(.!.......
DE00:  CF DF 13 23 05 C2 FD DD-C9 CD 98 DC 2A 8A DC 7E  ...#........*..~
DE10:  FE 20 CA 22 DE B7 CA 22-DE E5 CD 8C DC E1 23 C3  ..."..."......#.
DE20:  0F DE 3E 3F CD 8C DC CD-98 DC CD DD DD C3 82 DF  ..>?............
DE30:  1A B7 C8 FE 20 DA 09 DE-C8 FE 3D C8 FE 5F C8 FE  ..........=.._..
DE40:  2E C8 FE 3A C8 FE 3B C8-FE 3C C8 FE 3E C8 C9 1A  ...:..;..<..>...
DE50:  B7 C8 FE 20 C0 13 C3 4F-DE 85 6F D0 24 C9 3E 00  .......O..o.$.>.
DE60:  21 CD E3 CD 59 DE E5 E5-AF 32 F0 E3 2A 88 DC EB  !...Y....2..*...
DE70:  CD 4F DE EB 22 8A DC EB-E1 1A B7 CA 89 DE DE 40  .O.."..........@
DE80:  47 13 1A FE 3A CA 90 DE-1B 3A EF E3 77 C3 96 DE  G...:....:..w...
DE90:  78 32 F0 E3 70 13 06 08-CD 30 DE CA B9 DE 23 FE  x2..p....0....#.
DEA0:  2A C2 A9 DE 36 3F C3 AB-DE 77 13 05 C2 98 DE CD  *...6?...w......
DEB0:  30 DE CA C0 DE 13 C3 AF-DE 23 36 20 05 C2 B9 DE  0........#6.....
DEC0:  06 03 FE 2E C2 E9 DE 13-CD 30 DE CA E9 DE 23 FE  .........0....#.
DED0:  2A C2 D9 DE 36 3F C3 DB-DE 77 13 05 C2 C8 DE CD  *...6?...w......
DEE0:  30 DE CA F0 DE 13 C3 DF-DE 23 36 20 05 C2 E9 DE  0........#6.....
DEF0:  06 03 23 36 00 05 C2 F2-DE EB 22 88 DC E1 01 0B  ..#6......".....
DF00:  00 23 7E FE 3F C2 09 DF-04 0D C2 01 DF 78 B7 C9  .#~.?........x..
DF10:  44 49 52 20 45 52 41 20-54 59 50 45 53 41 56 45  DIR.ERA.TYPESAVE
DF20:  52 45 4E 20 55 53 45 52-00 16 00 00 00 00 21 10  REN.USER......!.
DF30:  DF 0E 00 79 FE 06 D0 11-CE E3 06 04 1A BE C2 4F  ...y...........O
DF40:  DF 13 23 05 C2 3C DF 1A-FE 20 C2 54 DF 79 C9 23  ..#..<.....T.y.#
DF50:  05 C2 4F DF 0C C3 33 DF-AF 32 07 DC 31 AB E3 C5  ..O...3..2..1...
DF60:  79 1F 1F 1F 1F E6 0F 5F-CD 15 DD CD B8 DC 32 AB  y......_......2.
DF70:  E3 C1 79 E6 0F 32 EF E3-CD BD DC 3A 07 DC B7 C2  ..y..2.....:....
DF80:  98 DF 31 AB E3 CD 98 DC-CD D0 DD C6 61 CD 8C DC  ..1.........a...
DF90:  3E 3E CD 8C DC CD 39 DD-11 80 00 CD D8 DD CD D0  >>....9.........
DFA0:  DD 32 EF E3 CD 5E DE C4-09 DE 3A F0 E3 B7 C2 A5  .2...^....:.....
DFB0:  E2 CD 2E DF 21 C1 DF 5F-16 00 19 19 7E 23 66 6F  ....!.._....~#fo
DFC0:  E9 77 E0 1F E1 5D E1 AD-E1 10 E2 8E E2 A5 E2 21  .w...].........!
DFD0:  F3 76 22 00 DC 21 00 DC-E9 01 DF DF C3 A7 DC 52  .v"..!.........R
DFE0:  65 61 64 20 65 72 72 6F-72 00 01 F0 DF C3 A7 DC  ead.error.......
DFF0:  4E 6F 20 66 69 6C 65 00-CD 5E DE 3A F0 E3 B7 C2  No.file..^.:....
E000:  09 DE 21 CE E3 01 0B 00-7E FE 20 CA 33 E0 23 D6  ..!.....~...3.#.
E010:  30 FE 0A D2 09 DE 57 78-E6 E0 C2 09 DE 78 07 07  0.....Wx.....x..
E020:  07 80 DA 09 DE 80 DA 09-DE 82 DA 09 DE 47 0D C2  .............G..
E030:  08 E0 C9 7E FE 20 C2 09-DE 23 0D C2 33 E0 78 C9  ...~.....#..3.x.
E040:  06 03 7E 12 23 13 05 C2-42 E0 C9 21 80 00 81 CD  ..~.#...B..!....
E050:  59 DE 7E C9 AF 32 CD E3-3A F0 E3 B7 C8 3D 21 EF  Y.~..2..:....=!.
E060:  E3 BE C8 C3 BD DC 3A F0-E3 B7 C8 3D 21 EF E3 BE  ......:....=!...
E070:  C8 3A EF E3 C3 BD DC CD-5E DE CD 54 E0 21 CE E3  .:......^..T.!..
E080:  7E FE 20 C2 8F E0 06 0B-36 3F 23 05 C2 88 E0 1E  ~.......6?#.....
E090:  00 D5 CD E9 DC CC EA DF-CA 1B E1 3A EE E3 0F 0F  ...........:....
E0A0:  0F E6 60 4F 3E 0A CD 4B-E0 17 DA 0F E1 D1 7B 1C  ..`O>..K......{.
E0B0:  D5 E6 03 F5 C2 CC E0 CD-98 DC C5 CD D0 DD C1 C6  ................
E0C0:  41 CD 92 DC 3E 3A CD 92-DC C3 D4 E0 CD A2 DC 3E  A...>:.........>
E0D0:  3A CD 92 DC CD A2 DC 06-01 78 CD 4B E0 E6 7F FE  :........x.K....
E0E0:  20 C2 F9 E0 F1 F5 FE 03-C2 F7 E0 3E 09 CD 4B E0  ...........>..K.
E0F0:  E6 7F FE 20 CA 0E E1 3E-20 CD 92 DC 04 78 FE 0C  .......>.....x..
E100:  D2 0E E1 FE 09 C2 D9 E0-CD A2 DC C3 D9 E0 F1 CD  ................
E110:  C2 DD C2 1B E1 CD E4 DC-C3 98 E0 D1 C3 86 E3 CD  ................
E120:  5E DE FE 0B C2 42 E1 01-52 E1 CD A7 DC CD 39 DD  ^....B..R.....9.
E130:  21 07 DC 35 C2 82 DF 23-7E FE 59 C2 82 DF 23 22  !..5...#~.Y...#"
E140:  88 DC CD 54 E0 11 CD E3-CD EF DC 3C CC EA DF C3  ...T.......<....
E150:  86 E3 41 6C 6C 20 28 79-2F 6E 29 3F 00 CD 5E DE  ..All.(y/n)?..^.
E160:  C2 09 DE CD 54 E0 CD D0-DC CA A7 E1 CD 98 DC 21  ....T..........!
E170:  F1 E3 36 FF 21 F1 E3 7E-FE 80 DA 87 E1 E5 CD FE  ..6.!..~........
E180:  DC E1 C2 A0 E1 AF 77 34-21 80 00 CD 59 DE 7E FE  ......w4!...Y.~.
E190:  1A CA 86 E3 CD 8C DC CD-C2 DD C2 86 E3 C3 74 E1  ..............t.
E1A0:  3D CA 86 E3 CD D9 DF CD-66 E0 C3 09 DE CD F8 DF  =.......f.......
E1B0:  F5 CD 5E DE C2 09 DE CD-54 E0 11 CD E3 D5 CD EF  ..^.....T.......
E1C0:  DC D1 CD 09 DD CA FB E1-AF 32 ED E3 F1 6F 26 00  .........2...o&.
E1D0:  29 11 00 01 7C B5 CA F1-E1 2B E5 21 80 00 19 E5  )...|....+.!....
E1E0:  CD D8 DD 11 CD E3 CD 04-DD D1 E1 C2 FB E1 C3 D4  ................
E1F0:  E1 11 CD E3 CD DA DC 3C-C2 01 E2 01 07 E2 CD A7  .......<........
E200:  DC CD D5 DD C3 86 E3 4E-6F 20 73 70 61 63 65 00  .......No.space.
E210:  CD 5E DE C2 09 DE 3A F0-E3 F5 CD 54 E0 CD E9 DC  .^....:....T....
E220:  C2 79 E2 21 CD E3 11 DD-E3 06 10 CD 42 E0 2A 88  .y.!........B.*.
E230:  DC EB CD 4F DE FE 3D CA-3F E2 FE 5F C2 73 E2 EB  ...O..=.?.._.s..
E240:  23 22 88 DC CD 5E DE C2-73 E2 F1 47 21 F0 E3 7E  #"...^..s..G!..~
E250:  B7 CA 59 E2 B8 70 C2 73-E2 70 AF 32 CD E3 CD E9  ..Y..p.s.p.2....
E260:  DC CA 6D E2 11 CD E3 CD-0E DD C3 86 E3 CD EA DF  ..m.............
E270:  C3 86 E3 CD 66 E0 C3 09-DE 01 82 E2 CD A7 DC C3  ....f...........
E280:  86 E3 46 69 6C 65 20 65-78 69 73 74 73 00 CD F8  ..File.exists...
E290:  DF FE 10 D2 09 DE 5F 3A-CE E3 FE 20 CA 09 DE CD  ......_:........
E2A0:  15 DD C3 89 E3 CD F5 DD-3A CE E3 FE 20 C2 C4 E2  ........:.......
E2B0:  3A F0 E3 B7 CA 89 E3 3D-32 EF E3 CD 29 DD CD BD  :......=2...)...
E2C0:  DC C3 89 E3 11 D6 E3 1A-FE 20 C2 09 DE D5 CD 54  ...............T
E2D0:  E0 D1 21 83 E3 CD 40 E0-CD D0 DC CA 6B E3 21 00  ..!...@.....k.!.
E2E0:  01 E5 EB CD D8 DD 11 CD-E3 CD F9 DC C2 01 E3 E1  ................
E2F0:  11 80 00 19 11 00 DC 7D-93 7C 9A D2 71 E3 C3 E1  .......}.|..q...
E300:  E2 E1 3D C2 71 E3 CD 66-E0 CD 5E DE 21 F0 E3 E5  ..=.q..f..^.!...
E310:  7E 32 CD E3 3E 10 CD 60-DE E1 7E 32 DD E3 AF 32  ~2..>..`..~2...2
E320:  ED E3 11 5C 00 21 CD E3-06 21 CD 42 E0 21 08 DC  ...\.!...!.B.!..
E330:  7E B7 CA 3E E3 FE 20 CA-3E E3 23 C3 30 E3 06 00  ~..>....>.#.0...
E340:  11 81 00 7E 12 B7 CA 4F-E3 04 23 13 C3 43 E3 78  ...~...O..#..C.x
E350:  32 80 00 CD 98 DC CD D5-DD CD 1A DD CD 00 01 31  2..............1
E360:  AB E3 CD 29 DD CD BD DC-C3 82 DF CD 66 E0 C3 09  ...)........f...
E370:  DE 01 7A E3 CD A7 DC C3-86 E3 42 61 64 20 6C 6F  ..z.......Bad.lo
E380:  61 64 00 43 4F 4D CD 66-E0 CD 5E DE 3A CE E3 D6  ad.COM.f..^.:...
E390:  20 21 F0 E3 B6 C2 09 DE-C3 82 DF 00 00 00 00 00  .!..............
E3A0:  00 00 00 00 00 00 00 00-00 00 00 00 00 24 24 24  .............$$$
E3B0:  20 20 20 20 20 53 55 42-00 00 00 00 00 00 00 00  .....SUB........
E3C0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 20 20  ................
E3D0:  20 20 20 20 20 20 20 20-20 00 00 00 00 00 20 20  ................
E3E0:  20 20 20 20 20 20 20 20-20 00 00 00 00 00 00 00  ................
E3F0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
E400:  00 16 00 00 00 00 C3 11-E4 99 E4 A5 E4 AB E4 B1  ................
E410:  E4 EB 22 43 E7 EB 7B 32-D6 F1 21 00 00 22 45 E7  .."C..{2..!.."E.
E420:  39 22 0F E7 31 41 E7 AF-32 E0 F1 32 DE F1 21 74  9"..1A..2..2..!t
E430:  F1 E5 79 FE 29 D0 4B 21-47 E4 5F 16 00 19 19 5E  ..y.).K!G._....^
E440:  23 56 2A 43 E7 EB E9 03-F2 C8 E6 90 E5 CE E6 12  #V*C............
E450:  F2 0F F2 D4 E6 ED E6 F3-E6 F8 E6 E1 E5 FE E6 7E  ...............~
E460:  F0 83 F0 45 F0 9C F0 A5-F0 AB F0 C8 F0 D7 F0 E0  ...E............
E470:  F0 E6 F0 EC F0 F5 F0 FE-F0 04 F1 0A F1 11 F1 2C  ...............,
E480:  E9 17 F1 1D F1 26 F1 2D-F1 41 F1 47 F1 4D F1 0E  .....&.-.A.G.M..
E490:  F0 53 F1 04 E7 04 E7 9B-F1 21 CA E4 CD E5 E4 FE  .S.......!......
E4A0:  03 CA 00 00 C9 21 D5 E4-C3 B4 E4 21 E1 E4 C3 B4  .....!.....!....
E4B0:  E4 21 DC E4 CD E5 E4 C3-00 00 42 64 6F 73 20 45  .!........Bdos.E
E4C0:  72 72 20 4F 6E 20 20 3A-20 24 42 61 64 20 53 65  rr.On..:.$Bad.Se
E4D0:  63 74 6F 72 24 53 65 6C-65 63 74 24 46 69 6C 65  ctor$Select$File
E4E0:  20 52 2F 4F 24 E5 CD C9-E5 3A 42 E7 C6 41 32 C6  .R/O$....:B..A2.
E4F0:  E4 01 BA E4 CD D3 E5 C1-CD D3 E5 21 0E E7 7E 36  ...........!..~6
E500:  00 B7 C0 C3 09 F2 CD FB-E4 CD 14 E5 D8 F5 4F CD  ..............O.
E510:  90 E5 F1 C9 FE 0D C8 FE-0A C8 FE 09 C8 FE 08 C8  ................
E520:  FE 20 C9 3A 0E E7 B7 C2-45 E5 CD 06 F2 E6 01 C8  ...:....E.......
E530:  CD 09 F2 FE 13 C2 42 E5-CD 09 F2 FE 03 CA 00 00  ......B.........
E540:  AF C9 32 0E E7 3E 01 C9-3A 0A E7 B7 C2 62 E5 C5  ..2..>..:....b..
E550:  CD 23 E5 C1 C5 CD 0C F2-C1 C5 3A 0D E7 B7 C4 0F  .#........:.....
E560:  F2 C1 79 21 0C E7 FE 7F-C8 34 FE 20 D0 35 7E B7  ..y!.....4...5~.
E570:  C8 79 FE 08 C2 79 E5 35-C9 FE 0A C0 36 00 C9 79  .y...y.5....6..y
E580:  CD 14 E5 D2 90 E5 F5 0E-5E CD 48 E5 F1 F6 40 4F  ........^.H...@O
E590:  79 FE 09 C2 48 E5 0E 20-CD 48 E5 3A 0C E7 E6 07  y...H....H.:....
E5A0:  C2 96 E5 C9 CD AC E5 0E-20 CD 0C F2 0E 08 C3 0C  ................
E5B0:  F2 0E 23 CD 48 E5 CD C9-E5 3A 0C E7 21 0B E7 BE  ..#.H....:..!...
E5C0:  D0 0E 20 CD 48 E5 C3 B9-E5 0E 0D CD 48 E5 0E 0A  ....H.......H...
E5D0:  C3 48 E5 0A FE 24 C8 03-C5 4F CD 90 E5 C1 C3 D3  .H...$...O......
E5E0:  E5 3A 0C E7 32 0B E7 2A-43 E7 4E 23 E5 06 00 C5  .:..2..*C.N#....
E5F0:  E5 CD FB E4 E6 7F E1 C1-FE 0D CA C1 E6 FE 0A CA  ................
E600:  C1 E6 FE 08 C2 16 E6 78-B7 CA EF E5 05 3A 0C E7  .......x.....:..
E610:  32 0A E7 C3 70 E6 FE 7F-C2 26 E6 78 B7 CA EF E5  2...p....&.x....
E620:  7E 05 2B C3 A9 E6 FE 05-C2 37 E6 C5 E5 CD C9 E5  ~.+......7......
E630:  AF 32 0B E7 C3 F1 E5 FE-10 C2 48 E6 E5 21 0D E7  .2........H..!..
E640:  3E 01 96 77 E1 C3 EF E5-FE 18 C2 5F E6 E1 3A 0B  >..w......._..:.
E650:  E7 21 0C E7 BE D2 E1 E5-35 CD A4 E5 C3 4E E6 FE  .!......5....N..
E660:  15 C2 6B E6 CD B1 E5 E1-C3 E1 E5 FE 12 C2 A6 E6  ..k.............
E670:  C5 CD B1 E5 C1 E1 E5 C5-78 B7 CA 8A E6 23 4E 05  ........x....#N.
E680:  C5 E5 CD 7F E5 E1 C1 C3-78 E6 E5 3A 0A E7 B7 CA  ........x..:....
E690:  F1 E5 21 0C E7 96 32 0A-E7 CD A4 E5 21 0A E7 35  ..!...2.....!..5
E6A0:  C2 99 E6 C3 F1 E5 23 77-04 C5 E5 4F CD 7F E5 E1  ......#w...O....
E6B0:  C1 7E FE 03 78 C2 BD E6-FE 01 CA 00 00 B9 DA EF  .~..x...........
E6C0:  E5 E1 70 0E 0D C3 48 E5-CD 06 E5 C3 01 E7 CD 15  ..p...H.........
E6D0:  F2 C3 01 E7 79 3C CA E0-E6 3C CA 06 F2 C3 0C F2  ....y<...<......
E6E0:  CD 06 F2 B7 CA 91 F1 CD-09 F2 C3 01 E7 3A 03 00  .............:..
E6F0:  C3 01 E7 21 03 00 71 C9-EB 4D 44 C3 D3 E5 CD 23  ...!..q..MD....#
E700:  E5 32 45 E7 C9 3E 01 C3-01 E7 00 02 00 00 00 00  .2E..>..........
E710:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
E720:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
E730:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
E740:  00 00 00 00 00 00 00 21-0B E4 5E 23 56 EB E9 0C  .......!..^#V...
E750:  0D C8 1A 77 13 23 C3 50-E7 3A 42 E7 4F CD 1B F2  ...w.#.P.:B.O...
E760:  7C B5 C8 5E 23 56 23 22-B3 F1 23 23 22 B5 F1 23  |..^#V#"..##"..#
E770:  23 22 B7 F1 23 23 EB 22-D0 F1 21 B9 F1 0E 08 CD  #"..##."..!.....
E780:  4F E7 2A BB F1 EB 21 C1-F1 0E 0F CD 4F E7 2A C6  O.*...!.....O.*.
E790:  F1 7C 21 DD F1 36 FF B7-CA 9D E7 36 00 3E FF B7  .|!..6.....6.>..
E7A0:  C9 CD 18 F2 AF 2A B5 F1-77 23 77 2A B7 F1 77 23  .....*..w#w*..w#
E7B0:  77 C9 CD 27 F2 C3 BB E7-CD 2A F2 B7 C8 21 09 E4  w..'.....*...!..
E7C0:  C3 4A E7 2A EA F1 0E 02-CD EA E8 22 E5 F1 22 EC  .J.*......."..".
E7D0:  F1 21 E5 F1 4E 23 46 2A-B7 F1 5E 23 56 2A B5 F1  .!..N#F*..^#V*..
E7E0:  7E 23 66 6F 79 93 78 9A-D2 FA E7 E5 2A C1 F1 7B  ~#foy.x.....*..{
E7F0:  95 5F 7A 9C 57 E1 2B C3-E4 E7 E5 2A C1 F1 19 DA  ._z.W.+....*....
E800:  0F E8 79 95 78 9C DA 0F-E8 EB E1 23 C3 FA E7 E1  ..y.x......#....
E810:  C5 D5 E5 EB 2A CE F1 19-44 4D CD 1E F2 D1 2A B5  ....*...DM....*.
E820:  F1 73 23 72 D1 2A B7 F1-73 23 72 C1 79 93 4F 78  .s#r.*..s#r.y.Ox
E830:  9A 47 2A D0 F1 EB CD 30-F2 4D 44 C3 21 F2 21 C3  .G*....0.MD.!.!.
E840:  F1 4E 3A E3 F1 B7 1F 0D-C2 45 E8 47 3E 08 96 4F  .N:......E.G>..O
E850:  3A E2 F1 0D CA 5C E8 B7-17 C3 53 E8 80 C9 2A 43  :....\....S...*C
E860:  E7 11 10 00 19 09 3A DD-F1 B7 CA 71 E8 6E 26 00  ......:....q.n&.
E870:  C9 09 5E 23 56 EB C9 CD-3E E8 4F 06 00 CD 5E E8  ..^#V...>.O...^.
E880:  22 E5 F1 C9 2A E5 F1 7D-B4 C9 3A C3 F1 2A E5 F1  "...*..}..:..*..
E890:  29 3D C2 90 E8 22 E7 F1-3A C4 F1 4F 3A E3 F1 A1  )=..."..:..O:...
E8A0:  B5 6F 22 E5 F1 C9 2A 43-E7 11 0C 00 19 C9 2A 43  .o"...*C......*C
E8B0:  E7 11 0F 00 19 EB 21 11-00 19 C9 CD AE E8 7E 32  ......!.......~2
E8C0:  E3 F1 EB 7E 32 E1 F1 CD-A6 E8 3A C5 F1 A6 32 E2  ...~2.....:...2.
E8D0:  F1 C9 CD AE E8 3A D5 F1-FE 02 C2 DE E8 AF 4F 3A  .....:........O:
E8E0:  E3 F1 81 77 EB 3A E1 F1-77 C9 0C 0D C8 7C B7 1F  ...w.:..w....|..
E8F0:  67 7D 1F 6F C3 EB E8 0E-80 2A B9 F1 AF 86 23 0D  g}.o.....*....#.
E900:  C2 FD E8 C9 0C 0D C8 29-C3 05 E9 C5 3A 42 E7 4F  .......)....:B.O
E910:  21 01 00 CD 04 E9 C1 79-B5 6F 78 B4 67 C9 2A AD  !......y.ox.g.*.
E920:  F1 3A 42 E7 4F CD EA E8-7D E6 01 C9 21 AD F1 4E  .:B.O...}...!..N
E930:  23 46 CD 0B E9 22 AD F1-2A C8 F1 23 EB 2A B3 F1  #F..."..*..#.*..
E940:  73 23 72 C9 CD 5E E9 11-09 00 19 7E 17 D0 21 0F  s#r..^.....~..!.
E950:  E4 C3 4A E7 CD 1E E9 C8-21 0D E4 C3 4A E7 2A B9  ..J.....!...J.*.
E960:  F1 3A E9 F1 85 6F D0 24-C9 2A 43 E7 11 0E 00 19  .:...o.$.*C.....
E970:  7E C9 CD 69 E9 36 00 C9-CD 69 E9 F6 80 77 C9 2A  ~..i.6...i...w.*
E980:  EA F1 EB 2A B3 F1 7B 96-23 7A 9E C9 CD 7F E9 D8  ...*..{.#z......
E990:  13 72 2B 73 C9 7B 95 6F-7A 9C 67 C9 0E FF 2A EC  .r+s.{.oz.g...*.
E9A0:  F1 EB 2A CC F1 CD 95 E9-D0 C5 CD F7 E8 2A BD F1  ..*..........*..
E9B0:  EB 2A EC F1 19 C1 0C CA-C4 E9 BE C8 CD 7F E9 D0  .*..............
E9C0:  CD 2C E9 C9 77 C9 CD 9C-E9 CD E0 E9 0E 01 CD B8  .,..w...........
E9D0:  E7 C3 DA E9 CD E0 E9 CD-B2 E7 21 B1 F1 C3 E3 E9  ..........!.....
E9E0:  21 B9 F1 4E 23 46 C3 24-F2 2A B9 F1 EB 2A B1 F1  !..N#F.$.*...*..
E9F0:  0E 80 C3 4F E7 21 EA F1-7E 23 BE C0 3C C9 21 FF  ...O.!..~#..<.!.
EA00:  FF 22 EA F1 C9 2A C8 F1-EB 2A EA F1 23 22 EA F1  ."...*...*..#"..
EA10:  CD 95 E9 D2 19 EA C3 FE-E9 3A EA F1 E6 03 06 05  .........:......
EA20:  87 05 C2 20 EA 32 E9 F1-B7 C0 C5 CD C3 E7 CD D4  .....2..........
EA30:  E9 C1 C3 9E E9 79 E6 07-3C 5F 57 79 0F 0F 0F E6  .....y..<_Wy....
EA40:  1F 4F 78 87 87 87 87 87-B1 4F 78 0F 0F 0F E6 1F  .Ox......Ox.....
EA50:  47 2A BF F1 09 7E 07 1D-C2 56 EA C9 D5 CD 35 EA  G*...~...V....5.
EA60:  E6 FE C1 B1 0F 15 C2 64-EA 77 C9 CD 5E E9 11 10  .......d.w..^...
EA70:  00 19 C5 0E 11 D1 0D C8-D5 3A DD F1 B7 CA 88 EA  .........:......
EA80:  C5 E5 4E 06 00 C3 8E EA-0D C5 4E 23 46 E5 79 B0  ..N.......N#F.y.
EA90:  CA 9D EA 2A C6 F1 7D 91-7C 98 D4 5C EA E1 23 C1  ...*..}.|..\..#.
EAA0:  C3 75 EA 2A C6 F1 0E 03-CD EA E8 23 44 4D 2A BF  .u.*.......#DM*.
EAB0:  F1 36 00 23 0B 78 B1 C2-B1 EA 2A CA F1 EB 2A BF  .6.#.x....*...*.
EAC0:  F1 73 23 72 CD A1 E7 2A-B3 F1 36 03 23 36 00 CD  .s#r...*..6.#6..
EAD0:  FE E9 0E FF CD 05 EA CD-F5 E9 C8 CD 5E E9 3E E5  ............^.>.
EAE0:  BE CA D2 EA 3A 41 E7 BE-C2 F6 EA 23 7E D6 24 C2  ....:A.....#~.$.
EAF0:  F6 EA 3D 32 45 E7 0E 01-CD 6B EA CD 8C E9 C3 D2  ..=2E....k......
EB00:  EA 3A D4 F1 C3 01 E7 C5-F5 3A C5 F1 2F 47 79 A0  .:.......:../Gy.
EB10:  4F F1 A0 91 E6 1F C1 C9-3E FF 32 D4 F1 21 D8 F1  O.......>.2..!..
EB20:  71 2A 43 E7 22 D9 F1 CD-FE E9 CD A1 E7 0E 00 CD  q*C."...........
EB30:  05 EA CD F5 E9 CA 94 EB-2A D9 F1 EB 1A FE E5 CA  ........*.......
EB40:  4A EB D5 CD 7F E9 D1 D2-94 EB CD 5E E9 3A D8 F1  J..........^.:..
EB50:  4F 06 00 79 B7 CA 83 EB-1A FE 3F CA 7C EB 78 FE  O..y......?.|.x.
EB60:  0D CA 7C EB FE 0C 1A CA-73 EB 96 E6 7F C2 2D EB  ..|.....s.....-.
EB70:  C3 7C EB C5 4E CD 07 EB-C1 C2 2D EB 13 23 04 0D  .|..N.....-..#..
EB80:  C3 53 EB 3A EA F1 E6 03-32 45 E7 21 D4 F1 7E 17  .S.:....2E.!..~.
EB90:  D0 AF 77 C9 CD FE E9 3E-FF C3 01 E7 CD 54 E9 0E  ..w....>.....T..
EBA0:  0C CD 18 EB CD F5 E9 C8-CD 44 E9 CD 5E E9 36 E5  .........D..^.6.
EBB0:  0E 00 CD 6B EA CD C6 E9-CD 2D EB C3 A4 EB 50 59  ...k.....-....PY
EBC0:  79 B0 CA D1 EB 0B D5 C5-CD 35 EA 1F D2 EC EB C1  y........5......
EBD0:  D1 2A C6 F1 7B 95 7A 9C-D2 F4 EB 13 C5 D5 42 4B  .*..{.z.......BK
EBE0:  CD 35 EA 1F D2 EC EB D1-C1 C3 C0 EB 17 3C CD 64  .5...........<.d
EBF0:  EA E1 D1 C9 79 B0 C2 C0-EB 21 00 00 C9 0E 00 1E  ....y....!......
EC00:  20 D5 06 00 2A 43 E7 09-EB CD 5E E9 C1 CD 4F E7  ....*C....^...O.
EC10:  CD C3 E7 C3 C6 E9 CD 54-E9 0E 0C CD 18 EB 2A 43  .......T......*C
EC20:  E7 7E 11 10 00 19 77 CD-F5 E9 C8 CD 44 E9 0E 10  .~....w.....D...
EC30:  1E 0C CD 01 EC CD 2D EB-C3 27 EC 0E 0C CD 18 EB  ......-..'......
EC40:  CD F5 E9 C8 0E 00 1E 0C-CD 01 EC CD 2D EB C3 40  ............-..@
EC50:  EC 0E 0F CD 18 EB CD F5-E9 C8 CD A6 E8 7E F5 E5  .............~..
EC60:  CD 5E E9 EB 2A 43 E7 0E-20 D5 CD 4F E7 CD 78 E9  .^..*C.....O..x.
EC70:  D1 21 0C 00 19 4E 21 0F-00 19 46 E1 F1 77 79 BE  .!...N!...F..wy.
EC80:  78 CA 8B EC 3E 00 DA 8B-EC 3E 80 2A 43 E7 11 0F  x...>....>.*C...
EC90:  00 19 77 C9 7E 23 B6 2B-C0 1A 77 13 23 1A 77 1B  ..w.~#.+..w.#.w.
ECA0:  2B C9 AF 32 45 E7 32 EA-F1 32 EB F1 CD 1E E9 C0  +..2E.2..2......
ECB0:  CD 69 E9 E6 80 C0 0E 0F-CD 18 EB CD F5 E9 C8 01  .i..............
ECC0:  10 00 CD 5E E9 09 EB 2A-43 E7 09 0E 10 3A DD F1  ...^...*C....:..
ECD0:  B7 CA E8 EC 7E B7 1A C2-DB EC 77 B7 C2 E1 EC 7E  ....~.....w....~
ECE0:  12 BE C2 1F ED C3 FD EC-CD 94 EC EB CD 94 EC EB  ................
ECF0:  1A BE C2 1F ED 13 23 1A-BE C2 1F ED 0D 13 23 0D  ......#.......#.
ED00:  C2 CD EC 01 EC FF 09 EB-09 1A BE DA 17 ED 77 01  ..............w.
ED10:  03 00 09 EB 09 7E 12 3E-FF 32 D2 F1 C3 10 EC 21  .....~.>.2.....!
ED20:  45 E7 35 C9 CD 54 E9 2A-43 E7 E5 21 AC F1 22 43  E.5..T.*C..!.."C
ED30:  E7 0E 01 CD 18 EB CD F5-E9 E1 22 43 E7 C8 EB 21  .........."C...!
ED40:  0F 00 19 0E 11 AF 77 23-0D C2 46 ED 21 0D 00 19  ......w#..F.!...
ED50:  77 CD 8C E9 CD FD EB C3-78 E9 AF 32 D2 F1 CD A2  w.......x..2....
ED60:  EC CD F5 E9 C8 2A 43 E7-01 0C 00 09 7E 3C E6 1F  .....*C.....~<..
ED70:  77 CA 83 ED 47 3A C5 F1-A0 21 D2 F1 A6 CA 8E ED  w...G:...!......
ED80:  C3 AC ED 01 02 00 09 34-7E E6 0F CA B6 ED 0E 0F  .......4~.......
ED90:  CD 18 EB CD F5 E9 C2 AC-ED 3A D3 F1 3C CA B6 ED  .........:..<...
EDA0:  CD 24 ED CD F5 E9 CA B6-ED C3 AF ED CD 5A EC CD  .$...........Z..
EDB0:  BB E8 AF C3 01 E7 CD 05-E7 C3 78 E9 3E 01 32 D5  ..........x.>.2.
EDC0:  F1 3E FF 32 D3 F1 CD BB-E8 3A E3 F1 21 E1 F1 BE  .>.2.....:..!...
EDD0:  DA E6 ED FE 80 C2 FB ED-CD 5A ED AF 32 E3 F1 3A  .........Z..2..:
EDE0:  45 E7 B7 C2 FB ED CD 77-E8 CD 84 E8 CA FB ED CD  E......w........
EDF0:  8A E8 CD D1 E7 CD B2 E7-C3 D2 E8 C3 05 E7 3E 01  ..............>.
EE00:  32 D5 F1 3E 00 32 D3 F1-CD 54 E9 2A 43 E7 CD 47  2..>.2...T.*C..G
EE10:  E9 CD BB E8 3A E3 F1 FE-80 D2 05 E7 CD 77 E8 CD  ....:........w..
EE20:  84 E8 0E 00 C2 6E EE CD-3E E8 32 D7 F1 01 00 00  .....n..>.2.....
EE30:  B7 CA 3B EE 4F 0B CD 5E-E8 44 4D CD BE EB 7D B4  ..;.O..^.DM...}.
EE40:  C2 48 EE 3E 02 C3 01 E7-22 E5 F1 EB 2A 43 E7 01  .H.>...."...*C..
EE50:  10 00 09 3A DD F1 B7 3A-D7 F1 CA 64 EE CD 64 E9  ...:...:...d..d.
EE60:  73 C3 6C EE 4F 06 00 09-09 73 23 72 0E 02 3A 45  s.l.O....s#r..:E
EE70:  E7 B7 C0 C5 CD 8A E8 3A-D5 F1 3D 3D C2 BB EE C1  .......:..==....
EE80:  C5 79 3D 3D C2 BB EE E5-2A B9 F1 57 77 23 14 F2  .y==....*..Ww#..
EE90:  8C EE CD E0 E9 2A E7 F1-0E 02 22 E5 F1 C5 CD D1  .....*....".....
EEA0:  E7 C1 CD B8 E7 2A E5 F1-0E 00 3A C4 F1 47 A5 B8  .....*....:..G..
EEB0:  23 C2 9A EE E1 22 E5 F1-CD DA E9 CD D1 E7 C1 C5  #...."..........
EEC0:  CD B8 E7 C1 3A E3 F1 21-E1 F1 BE DA D2 EE 77 34  ....:..!......w4
EED0:  0E 02 00 00 21 00 00 F5-CD 69 E9 E6 7F 77 F1 FE  ....!....i...w..
EEE0:  7F C2 00 EF 3A D5 F1 FE-01 C2 00 EF CD D2 E8 CD  ....:...........
EEF0:  5A ED 21 45 E7 7E B7 C2-FE EE 3D 32 E3 F1 36 00  Z.!E.~....=2..6.
EF00:  C3 D2 E8 AF 32 D5 F1 C5-2A 43 E7 EB 21 21 00 19  ....2...*C..!!..
EF10:  7E E6 7F F5 7E 17 23 7E-17 E6 1F 4F 7E 1F 1F 1F  ~...~.#~...O~...
EF20:  1F E6 0F 47 F1 23 6E 2C-2D 2E 06 C2 8B EF 21 20  ...G.#n,-.....!.
EF30:  00 19 77 21 0C 00 19 79-96 C2 47 EF 21 0E 00 19  ..w!...y..G.!...
EF40:  78 96 E6 7F CA 7F EF C5-D5 CD A2 EC D1 C1 2E 03  x...............
EF50:  3A 45 E7 3C CA 84 EF 21-0C 00 19 71 21 0E 00 19  :E.<...!...q!...
EF60:  70 CD 51 EC 3A 45 E7 3C-C2 7F EF C1 C5 2E 04 0C  p.Q.:E.<........
EF70:  CA 84 EF CD 24 ED 2E 05-3A 45 E7 3C CA 84 EF C1  ....$...:E.<....
EF80:  AF C3 01 E7 E5 CD 69 E9-36 C0 E1 C1 7D 32 45 E7  ......i.6...}2E.
EF90:  C3 78 E9 0E FF CD 03 EF-CC C1 ED C9 0E 00 CD 03  .x..............
EFA0:  EF CC 03 EE C9 EB 19 4E-06 00 21 0C 00 19 7E 0F  .......N..!...~.
EFB0:  E6 80 81 4F 3E 00 88 47-7E 0F E6 0F 80 47 21 0E  ...O>..G~....G!.
EFC0:  00 19 7E 87 87 87 87 F5-80 47 F5 E1 7D E1 B5 E6  ..~......G..}...
EFD0:  01 C9 0E 0C CD 18 EB 2A-43 E7 11 21 00 19 E5 72  .......*C..!...r
EFE0:  23 72 23 72 CD F5 E9 CA-0C F0 CD 5E E9 11 0F 00  #r#r.......^....
EFF0:  CD A5 EF E1 E5 5F 79 96-23 78 9E 23 7B 9E DA 06  ....._y.#x.#{...
F000:  F0 73 2B 70 2B 71 CD 2D-EB C3 E4 EF E1 C9 2A 43  .s+p+q.-......*C
F010:  E7 11 20 00 CD A5 EF 21-21 00 19 71 23 70 23 77  .......!!..q#p#w
F020:  C9 2A AF F1 3A 42 E7 4F-CD EA E8 E5 EB CD 59 E7  .*..:B.O......Y.
F030:  E1 CC 47 E7 7D 1F D8 2A-AF F1 4D 44 CD 0B E9 22  ..G.}..*..MD..."
F040:  AF F1 C3 A3 EA 3A D6 F1-21 42 E7 BE C8 77 C3 21  .....:..!B...w.!
F050:  F0 3E FF 32 DE F1 2A 43-E7 7E E6 1F 3D 32 D6 F1  .>.2..*C.~..=2..
F060:  FE 1E D2 75 F0 3A 42 E7-32 DF F1 7E 32 E0 F1 E6  ...u.:B.2..~2...
F070:  E0 77 CD 45 F0 3A 41 E7-2A 43 E7 B6 77 C9 3E 22  .w.E.:A.*C..w.>"
F080:  C3 01 E7 21 00 00 22 AD-F1 22 AF F1 AF 32 42 E7  ...!..".."...2B.
F090:  21 80 00 22 B1 F1 CD DA-E9 C3 21 F0 CD 72 E9 CD  !.."......!..r..
F0A0:  51 F0 C3 51 EC CD 51 F0-C3 A2 EC 0E 00 EB 7E FE  Q..Q..Q.......~.
F0B0:  3F CA C2 F0 CD A6 E8 7E-FE 3F C4 72 E9 CD 51 F0  ?......~.?.r..Q.
F0C0:  0E 0F CD 18 EB C3 E9 E9-2A D9 F1 22 43 E7 CD 51  ........*.."C..Q
F0D0:  F0 CD 2D EB C3 E9 E9 CD-51 F0 CD 9C EB C3 01 EB  ..-.....Q.......
F0E0:  CD 51 F0 C3 BC ED CD 51-F0 C3 FE ED CD 72 E9 CD  .Q.....Q.....r..
F0F0:  51 F0 C3 24 ED CD 51 F0-CD 16 EC C3 01 EB 2A AF  Q..$..Q.......*.
F100:  F1 C3 29 F1 3A 42 E7 C3-01 E7 EB 22 B1 F1 C3 DA  ..).:B....."....
F110:  E9 2A BF F1 C3 29 F1 2A-AD F1 C3 29 F1 CD 51 F0  .*...).*...)..Q.
F120:  CD 3B EC C3 01 EB 2A BB-F1 22 45 E7 C9 3A D6 F1  .;....*.."E..:..
F130:  FE FF C2 3B F1 3A 41 E7-C3 01 E7 E6 1F 32 41 E7  ...;.:A......2A.
F140:  C9 CD 51 F0 C3 93 EF CD-51 F0 C3 9C EF CD 51 F0  ..Q.....Q.....Q.
F150:  C3 D2 EF 2A 43 E7 7D 2F-5F 7C 2F 2A AF F1 A4 57  ...*C.}/_|/*...W
F160:  7D A3 5F 2A AD F1 EB 22-AF F1 7D A3 6F 7C A2 67  }._*..."..}.o|.g
F170:  22 AD F1 C9 3A DE F1 B7-CA 91 F1 2A 43 E7 36 00  "...:......*C.6.
F180:  3A E0 F1 B7 CA 91 F1 77-3A DF F1 32 D6 F1 CD 45  :......w:..2...E
F190:  F0 2A 0F E7 F9 2A 45 E7-7D 44 C9 CD 51 F0 3E 02  .*...*E.}D..Q.>.
F1A0:  32 D5 F1 0E 00 CD 07 EF-CC 03 EE C9 E5 00 00 00  2...............
F1B0:  00 80 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
F1C0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
F1D0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
F1E0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
F1F0:  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
F200:  C3 00 00 C3 00 00 C3 00-00 C3 00 00 C3 00 00 C3  ................
F210:  00 00 C3 00 00 C3 00 00-C3 00 00 C3 00 00 C3 00  ................
F220:  00 C3 00 00 C3 00 00 C3-00 00 C3 00 00 C3 00 00  ................
F230:  C3 00 00               -                         ................
